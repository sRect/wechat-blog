{"list": [{"id":"d4JkI4HKtqvsg8a-o2FW9","title":"一次页面请求loading转圈圈没停止bug的追踪","keywords":["uniapp"," 微信小程序"," javascript"],"date":"2023-08-01","fileName":"refresh-token","content":"\n- [本文掘金链接](https://juejin.cn/post/7262201057957429304)\n\n> 终极省流：项目中封装的请求方法存在问题，刷新token成功后，没把旧的请求结果返回到业务代码中，Promise一直处在pending状态，所以关闭loading方法一直没执行，导致一直在转圈圈\n\n## 1. 项目背景\n\n+ uniapp 微信小程序项目\n+ 项目中采用JWT登录，登录成功后返回`access_token`和`refresh_token`，其中access_token用于每次请求的时候在header中带上令牌，`Authorization: Bearer {{access_token}}`，refresh_token用于access_token过期失效后刷新新的access_token\n+ 网络请求采用的是基于`uni.request`自行封装的方法\n\n## 2. 发现bug及分析\n\n### 2.1 误会了mescroll-uni\n\n+ 发生bug的页面，是一个列表页，请求需要携带token的，列表里采用了[mescroll-uni](http://www.mescroll.com/uni.html#options)库（是专门用在uni-app的下拉刷新和上拉加载的组件, 支持一套代码编译到iOS、Android、H5、小程序等多个平台）\n\n> mescroll-uni简单使用示例\n\n```html\n<template>\n  <mescroll-uni ref=\"mescrollRef\" bottom=\"0\" :safearea=\"true\" :down=\"downOption\" :up=\"upOption\" @init=\"mescrollInit\" @down=\"downCallback\" @up=\"upCallback\">\n    <view v-for=\"item in list\" :key=\"item.id\">\n      <!-- ... -->\n    </view>\n  </mescroll-uni>\n</template>\n\n<script>\nimport MescrollMixin from \"mescroll-uni/mescroll-mixins.js\";\nimport MescrollUni from \"mescroll-uni/mescroll-uni.vue\";\n\nexport default {\n  mixins: [MescrollMixin],\n  components: {\n    \"mescroll-uni\": MescrollUni\n  },\n  data() {\n    return {\n      list: [],\n      upOption: {\n        use: true, // 是否启用上拉加载; 默认true\n        auto: true, // 是否在初始化完毕之后自动执行上拉加载的回调; 默认true\n        page: {\n          num: 0, // 当前页码,默认0,回调之前会加1,即callback(page)会从1开始\n          size: 10 // 每页数据的数量,默认10\n        },\n        noMoreSize: 1, // 配置列表的总数量要大于等于5条才显示'-- END --'的提示\n        empty: {\n          tip: '暂无数据',\n          icon: emptyPNG\n        },\n        textNoMore: '---没有更多了---'\n      },\n    }\n  },\n  methods: {\n    async upCallback(page) {\n      try {\n        const res = await http('/api/xxx/getList', \"POST\");\n\n        if (res.code === 200) {\n            // 接口返回的当前页数据列表\n            let curPageData = res.data.list;\n            // 接口返回的总长度\n            let totalSize = res.data.total;\n            // 接口返回的当前页数据长度\n            let curPageLen = res.data.list.length;\n\n            this.list = page.num === 1 ? curPageData : [...this.list, ...curPageData];\n            this.mescroll.endBySize(curPageLen, totalSize);\n          }\n      } catch(e) {\n        console.error(e);\n        this.mescroll.endErr();\n      }\n    },\n  }\n}\n</script>\n```\n\n+ 当access_token失效后，而这时候刚好点击进入到了这个列表页，而mescroll-uni在upOption中配置了`auto: true`(即初始化完毕之后自动执行上拉加载的回调)，此时会走刷新token操作，token刷新成功后，会重新把刚才的请求走一遍，然后把结果返回给页面。问题就出现在这，由于封装的请求方法中的刷新token模块有问题，没有把重新请求的结果返回给页面，导致mescroll-uni一直在loading。\n\n+ 而在微信开发者工具network中看到没任何问题，请求A返回code为4011，token失效，发起refresh_token请求，然后再次发送请求A，步骤没错。console控制台也没有任何报错。\n\n+ 当重新下拉刷新后，列表就重新渲染了(因为此时发起的请求，带的token已经是刷新过后的新token)，这样造成我一度认为mescroll-uni库有bug，无语！\n\n### 2.2 token刷新方法存在问题\n\n> 一次偶然在请求前加了`uni.showLoading`，发现token刷新成功后，转圈圈居然还在，`uni.hideLoading`未执行，让我恍然大悟，项目中自行封装的`http`方法有问题\n\n```javascript\nexport default {\n\tmethods: {\n\t\tasync fetchData() {\n\t\t\tuni.showLoading();\n\t\t\ttry {\n\t\t\t\tconst res = await http(\"/api/xxx/xxx\", \"POST\");\n\t\t\t\tuni.hideLoading();\n\t\t\t} catch (e) {\n\t\t\t\tuni.hideLoading();\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t}\n\t},\n\tasync onLoad() {\n\t\tawait this.fetchData();\n\t}\n}\n```\n\n**存在问题**的`http`请求方法代码片段：\n\n```javascript\nimport config from \"./config\";\n\nconst http = (path,method,params,header) => {\n\treturn new Promise((resolve, reject) => {\n\t\tuni.request({\n\t\t\tmethod: method,\n\t\t\turl,\n\t\t\theader: {\n\t\t\t\t...header,\n\t\t\t\tAuthorization: uni.getStorageSync(\"access_token\")\n\t\t\t\t\t? \"Bearer \" + uni.getStorageSync(\"access_token\")\n\t\t\t\t\t: \"\",\n\t\t\t},,\n\t\t\tdata: params,\n\t\t\tsuccess: async (res) => {\n\t\t\t\tconst {\n\t\t\t\t\tdata: { code, msg }} = res;\n\t\t\t\tif (code >= 200 && code < 300) {\n\t\t\t\t\tresolve(res.data);\n\t\t\t\t} else if (code === 4011) {\n\t\t\t\t\t// ==>问题就出现在这\n\t\t\t\t\trefreshToken({ path, method, params, isRsa });\n\t\t\t\t} else if (code === 4013) {\n\t\t\t\t\tgotoLoginPage();\n\t\t\t\t} else {\n\t\t\t\t\treject(res.data);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfail: (err) => {\n\t\t\t\tconsole.error(\"请求失败\", err);\n\t\t\t\treject(err);\n\t\t\t},\n\t\t});\n\t});\n};\n\nfunction refreshToken(failParams) {\n\tuni.request({\n\t\tmethod: \"POST\",\n\t\turl: config.baseUrl + \"/api/xxx/token/reset\",\n\t\tdata: {\n\t\t\trefresh_token: uni.getStorageSync(\"refresh_token\"),\n\t\t},\n\t\tsuccess: (res) => {\n\t\t\tconst { code, data } = res.data;\n\n\t\t\tif (code === 200) {\n\t\t\t\tuni.setStorageSync(\"access_token\", data.access_token);\n\t\t\t\tuni.setStorageSync(\"refresh_token\", data.refresh_token);\n\n\t\t\t\tconst { path, method, params, isRsa } = failParams;\n\t\t\t\t// 这里虽然把那次请求重新发送出去，但是结果没返回给页面\n\t\t\t\thttp(path, method, params, isRsa);\n\t\t\t} else if (code === 4012) {\n\t\t\t\t// refresh_token也失效了，重新登录\n\t\t\t\tgotoLoginPage();\n\t\t\t}\n\t\t},\n\t\tfail: (err) => {\n\t\t\tconsole.error(\"请求失败\", err);\n\t\t},\n\t});\n}\n\nexport default http;\n```\n\n**分析**：上面代码中可以看到，当返回4011 token失效后，refreshToken方法中，刷新token后，重新执行http方法发起请求，这时候的结果，没有resolve或者reject回去，导致页面那一次请求一直处在pending状态，而[uni.request](https://uniapp.dcloud.net.cn/api/request/request.html#request)方法默认超时时间为60000ms(即1分钟)，没等到1分钟，就手动离开这个页面了，导致超时的错误也没看到。refreshToken方法里虽然把那一次请求重新发出了，但这里就如同你用postman，请求成功与否和页面代码已无关\n\n## 3. 无感刷新的修改\n\n> 项目是中途接手，那就基于这个继续修改，就不替换了\n\n**两个注意点：**\n\n1. 当access_token失效后，此时刷新token，要防止重复刷新，用一个变量控制\n2. 当access_token失效后，此时正在刷新token，如果页面中此时还有其它请求正在发出，需要存起来(Promise在pending状态)，等token刷新成功后，再把刚才存起来的请求按顺序一个个拿出来，按顺序重新发起请求，并把结果返回给页面(把Promise状态改为fulfilled或者rejected状态)\n\n改造后的完整代码片段：\n\n```javascript\n// 标记token是否正在刷新\nlet isRefreshing = false;\n// 需要重新发起请求的队列\nconst oldRequestQueue = [];\n\nconst http = (path,method,params,header) => {\n\treturn new Promise((resolve, reject) => {\n\t\tuni.request({\n\t\t\tmethod: method,\n\t\t\turl,\n\t\t\theader: {\n\t\t\t\t...header,\n\t\t\t\tAuthorization: uni.getStorageSync(\"access_token\")\n\t\t\t\t\t? \"Bearer \" + uni.getStorageSync(\"access_token\")\n\t\t\t\t\t: \"\",\n\t\t\t},\n\t\t\tdata: params,\n\t\t\tsuccess: async (res) => {\n\t\t\t\tconst {\n\t\t\t\t\tdata: { code, msg },} = res;\n\t\t\t\tif (code >= 200 && code < 300) {\n\t\t\t\t\tresolve(res.data);\n\t\t\t\t} else if (code === 4011) {\n\t\t\t\t\t// 改造重点在这==>\n\t\t\t\t\tif(!isRefreshing) {\n            isRefreshing = true;\n\t\t\t\t\t\t// 将当前这次请求存入requests中\n\t\t\t\t\t\toldRequestQueue.push(() => Promise.resolve({ resolve, reject, path, method, params, isRsa }));\n\n\t\t\t\t\t\tconsole.log(\"准备开始刷新token\");\n\t\t\t\t\t\tlet refreshTokenIsOk = \"\";\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trefreshTokenIsOk = await refreshToken();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.error(\"刷新token错误:\", error);\n\t\t\t\t\t\t\toldRequestQueue.length = 0;\n\t\t\t\t\t\t\tgotoLoginPage();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tisRefreshing = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (refreshTokenIsOk === \"refresh_token_ok\") {\n\t\t\t\t\t\t\tconsole.log(\"刷新token成功， oldRequestQueue.length:\", oldRequestQueue.length);\n\n\t\t\t\t\t\t\tif (oldRequestQueue.length > 0) {\n\t\t\t\t\t\t\t\t// token 刷新后将oldRequestQueue村的请求重新执行\n\t\t\t\t\t\t\t\tfor await (let fn of oldRequestQueue) {\n\t\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\t\tresolve: oldResolve,\n\t\t\t\t\t\t\t\t\t\treject: oldReject,\n\t\t\t\t\t\t\t\t\t\tpath: oldPath,\n\t\t\t\t\t\t\t\t\t\tmethod: oldMethod,\n\t\t\t\t\t\t\t\t\t\tparams: oldParams,\n\t\t\t\t\t\t\t\t\t\tisRsa: oldIsRsa,\n\t\t\t\t\t\t\t\t\t} = await fn();\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tconst res = await http(oldPath, oldMethod, oldParams, oldIsRsa);\n\t\t\t\t\t\t\t\t\t\toldResolve(res);\n\t\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\t\toldReject(error);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// 重新请求完清空requests\n\t\t\t\t\t\t\t\toldRequestQueue.length = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 此时正在刷新token，有请求过来，将请求也存入oldRequestQueue中\n\t\t\t\t\t\tconsole.log(\"正在刷新token,存入oldRequestQueue:\", path);\n\t\t\t\t\t\toldRequestQueue.push(() => Promise.resolve({ resolve, reject, path, method, params, isRsa }));\n\t\t\t\t\t}\n\t\t\t\t} else if (code === 4013) {\n\t\t\t\t\tgotoLoginPage();\n\t\t\t\t} else {\n\t\t\t\t\treject(res.data);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfail: (err) => {\n\t\t\t\tconsole.error(\"请求失败\", err);\n\t\t\t\treject(err);\n\t\t\t},\n\t\t});\n\t});\n};\n\nasync function refreshToken() {\n\tuni.request({\n\t\tmethod: \"POST\",\n\t\turl: config.baseUrl + \"/api/xxx/token/reset\",\n\t\tdata: {\n\t\t\trefresh_token: uni.getStorageSync(\"refresh_token\"),\n\t\t},\n\t\tsuccess: (res) => {\n\t\t\tconst { code, data } = res.data;\n\n\t\t\tif (code === 200) {\n\t\t\t\tuni.setStorageSync(\"access_token\", data.access_token);\n\t\t\t\tuni.setStorageSync(\"refresh_token\", data.refresh_token);\n\n\t\t\t\treturn Promise.resolve(\"refresh_token_ok\");\n\t\t\t} else if (code === 4012) {\n\t\t\t\t// refresh_token也失效了，重新登录\n\t\t\t\toldRequestQueue.length = 0;\n\t\t\t\tgotoLoginPage();\n\t\t\t}\n\t\t},\n\t\tfail: (err) => {\n\t\t\tconsole.error(\"请求失败\", err);\n\t\t\treturn Promise.reject(err);\n\t\t},\n\t});\n}\n\nexport default http;\n```\n\n## 4. 参考资料\n\n1. [封装 axios 拦截器实现用户无感刷新 access_token](https://juejin.cn/post/6854573219119104014)\n\n------\n\n![img](../img/gzh/gzh_qrcode.jpg)\n"},{"id":"DMqq0w7Lu4xQmkQs_uxSG","title":"一次uniapp HbuilderX创建的小程序项目中使用tailwindcss折腾记录","keywords":["uniapp"," HbuilderX"," tailwindcss"," 微信小程序"],"date":"2023-07-18","fileName":"hbuilderx-tailwindcss","content":"\n- [本文掘金链接](https://juejin.cn/post/7257022428193636409)\n\n> 如题，是基于HbuilderX创建的小程序项目，非cli方式创建的项目\n\n## 1.啰嗦两句\n\n+ [tailwindcss](https://www.tailwindcss.cn)已经出来很长时间了，在前端娱乐圈里也是炒的火热。这个工具还没使用过，[windicss](https://windicss.org/guide/)这个新的轮子又都扎我脸上了。\n+ 之前被uniapp HbuilderX方式创建的h5项目折腾过，这篇文章[《uniapp 打包 h5 问题总结》](https://juejin.cn/post/7129492032241795080)有记录。那这次为什么还要用HbuilderX这种方式，没办法，一开始项目不是我创建的。\n\n省流（得出结论）：\n+ uniapp HbuilderX方式被高度封装，都被封装到他的应用里去了，虽暴露出来的几个文件和方法，后续配置起来还是费劲。\n+ 而用vue-cli方式创建的，配置文件全部暴露，方便后续修改\n\n## 2.开始配置\n\n> + 根据这位兄弟的分享，[Hbuilder创建的uniapp工程，使用tailwindcss最优雅的方式](https://ask.dcloud.net.cn/article/40098) 提示，HbuilderX创建的uniapp工程也是内置了postcss，但都是高度封装的。\n> + 想基于它内部的postcss中添加`tailwindcss plugins`，很难，路会走偏(亲测，路确实很偏，一堆报错，还会和uview-ui冲突)\n> + 所以这里直接使用`Tailwind CLI`方式\n\n根据[文档](https://www.tailwindcss.cn/docs/installation)\n\n1. `npm install -D tailwindcss`安装\n\n2. `npx tailwindcss init`，生成`tailwind.config.js` 配置文件\n\n```javascript\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n\t// https://ask.dcloud.net.cn/article/40098\n  \tseparator: '__', // 如果是小程序项目需要设置这一项，将 : 选择器替换成 __，之后 hover:bg-red-500 将改为 hover__bg-red-500  \n  \tcorePlugins: {  \n  \t\t// 预设样式  \n  \t\tpreflight: false, // 一般uniapp都有预设样式，所以不需要tailwindcss的预设  \n  \t\t// 以下功能小程序不支持  \n  \t\tspace: false, // > 子节点选择器  \n  \t\tdivideWidth: false,  \n  \t\tdivideColor: false,  \n  \t\tdivideStyle: false,  \n  \t\tdivideOpacity: false,  \n  \t},\n\t  content: [\n\t\t  './pages/**/*.{vue,js}',\n\t\t  // './main.js',  \n\t\t  './App.vue',  \n\t\t  // './index.html' \n\t  ],\n\t  theme: {\n\t\textend: {},\n\t  },\n\t  plugins: [],\n}\n```\n3. 根目录新建`tailwind-input.css`\n\n```css\n/* @tailwind base; */\n@tailwind components;\n@tailwind utilities;\n```\n\n4. 开启 Tailwind CLI 构建流程\n\n```sh\nnpx tailwindcss -i ./tailwind-input.css -o ./static/css/tailwind.css --watch\n```\n\n5. `App.vue`中引入编译过的`tailwind.css`\n\n```diff\n<style lang=\"scss\">\n\t@import \"@/uni_modules/uview-ui/index.scss\";\n+\t@import url(\"./static/css/tailwind.css\");\n</style>\n```\n\n其实到这里已经ok了，缺点就是每次运行项目都要自己手动去执行`npx tailwindcss -i ./tailwind-input.css -o ./static/css/tailwind.css --watch`,不方便\n所以必须改成自动化\n\n## 3.启动项目自动化tailwindcss编译\n\n> 庆幸的是，uniapp官方暴露出来了`vue.config.js`，我们可以在这里面配置\n\n### 3.1 `package.json`中添加自定义脚本运行\n\n```json\n{\n\t\"scripts\": {\n\t\t\"tailwind:dev\": \"npx tailwindcss -i ./tailwind-input.css -o ./static/css/tailwind.css --watch\",\n\t\t\"tailwind:prod\": \"npx tailwindcss -i ./tailwind-input.css -o ./static/css/tailwind.css\"\n\t},\n\t\"uni-app\": {\n\t\t\"scripts\": {\n\t\t\t\"dev:mp-weixin:dev\": {\n\t\t\t\t\"title\": \"本地开发-测试环境接口\",\n\t\t\t\t\"browser\": \"\",\n\t\t\t\t\"env\": {\n\t\t\t\t\t\"UNI_PLATFORM\": \"mp-weixin\",\n\t\t\t\t\t\"NODE_ENV\": \"development\",\n\t\t\t\t\t\"BASE_URL_ENV\": \"development\"\n\t\t\t\t},\n\t\t\t\t\"define\": {\n\t\t\t\t\t\"CUSTOM-CONST\": true\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"dev:mp-weixin:prod\": {\n\t\t\t\t\"title\": \"本地开发-正式环境接口\",\n\t\t\t\t\"browser\": \"\",\n\t\t\t\t\"env\": {\n\t\t\t\t\t\"UNI_PLATFORM\": \"mp-weixin\",\n\t\t\t\t\t\"NODE_ENV\": \"development\",\n\t\t\t\t\t\"BASE_URL_ENV\": \"production\"\n\t\t\t\t},\n\t\t\t\t\"define\": {\n\t\t\t\t\t\"CUSTOM-CONST\": true\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"build:mp-weixin:dev\": {\n\t\t\t\t\"title\": \"打包-测试环境接口\",\n\t\t\t\t\"browser\": \"\",\n\t\t\t\t\"env\": {\n\t\t\t\t\t\"UNI_PLATFORM\": \"mp-weixin\",\n\t\t\t\t\t\"NODE_ENV\": \"production\",\n\t\t\t\t\t\"BASE_URL_ENV\": \"development\"\n\t\t\t\t},\n\t\t\t\t\"define\": {\n\t\t\t\t\t\"CUSTOM-CONST\": true\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"build:mp-weixin:prod\": {\n\t\t\t\t\"title\": \"打包-正式环境接口\",\n\t\t\t\t\"browser\": \"\",\n\t\t\t\t\"env\": {\n\t\t\t\t\t\"UNI_PLATFORM\": \"mp-weixin\",\n\t\t\t\t\t\"NODE_ENV\": \"production\",\n\t\t\t\t\t\"BASE_URL_ENV\": \"production\"\n\t\t\t\t},\n\t\t\t\t\"define\": {\n\t\t\t\t\t\"CUSTOM-CONST\": true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 3.2 根目录新建`vue.config.js`\n\n> + 利用`child_process.exec`执行子进程，运行`npx tailwindcss -i ./tailwind-input.css -o ./static/css/tailwind.css --watch`,\n> + 问题也就出现在这，child_process.exec默认用的是`/bin/sh`执行，虽然可以配置修改成`{shell: '/bin/bash'}`或者`{shell: '/bin/zsh'}`,\n> + 但是tailwindcss每次都报错，因为HbuilderX执行vue.config.js里采用的nodejs版本是`v12`，通过`console.log(process.version)`可以看到nodejs当前版本\n> + 为什么它这里采用的是nodejs v12版本，暂不清楚，但本地zsh，执行`node -v`，是v16版本\n> + nodejs v12版本执行tailwindcss编译，[Npx tailwindcss results in \"Unexpected Token .\"](https://github.com/tailwindlabs/tailwindcss/discussions/8807)\n> + 根据提示，解决办法就是切换当前nodejs版本为v16\n\n![](../img/hbuilderx-tailwindcss/nvm.png)\n\n```javascript\nconst {exec} = require('child_process');\n\nconsole.log(\"process.env.UNI_SCRIPT:\", process.env.UNI_SCRIPT);\nconsole.log(\"process.env.NODE_ENV:\", process.env.NODE_ENV);\nconsole.log(\"当前nodejs版本\", process.version);\n\nconst isDev = process.env.NODE_ENV === 'development';\n\nexec(\n\tisDev ? 'npm run tailwind:dev' : '\"npm run tailwind:prod',\n\t{ cwd: __dirname, shell: \"/bin/bash\", },\n\t(error, stdout, stderr) => {  \n\t\tif (error) {  \n\t\t\tconsole.error('[tailwindcss error]', error);\n\t\t\tconsole.error(\"error.stderr:\", stderr);\n\t\t} \n\t\t\n\t\tisDev ? console.log(`[tailwindcss stdout]: ${stdout}`)\n\t\t\t: console.log('[tailwindcss] 生产环境打包完成');\n\t}\n);\n\nmodule.exports = {};\n```\n\n报错信息如下：\n```\n[tailwindcss error] Error: Command failed: npm run tailwind:dev\n14:38:24.610 Unexpected token '.'\n14:38:24.622 npm ERR! code ELIFECYCLE\n14:38:24.623 npm ERR! errno 1\n14:38:24.638 npm ERR! @ tailwind:dev: `npx tailwindcss -i ./tailwind-input.css -o ./static/css/tailwind.css --watch`\n14:38:24.639 npm ERR! Exit status 1\n14:38:24.652 npm ERR! \n14:38:24.668 npm ERR! Failed at the @ tailwind:dev script.\n14:38:24.669 npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\n14:38:24.686 npm ERR! A complete log of this run can be found in:\n14:38:24.702 npm ERR!     /Users/xxx/.npm/_logs/2023-07-18T06_38_23_626Z-debug.log\n14:38:24.719     at ChildProcess.exithandler (child_process.js:308:12)\n14:38:24.740     at ChildProcess.emit (events.js:314:20)\n14:38:24.757     at maybeClose (internal/child_process.js:1022:16)\n14:38:24.774     at Socket.<anonymous> (internal/child_process.js:444:11)\n14:38:24.790     at Socket.emit (events.js:314:20)\n14:38:24.791     at Pipe.<anonymous> (net.js:675:12) {\n14:38:24.807   killed: false,\n14:38:24.810   code: 1,\n14:38:24.825   signal: null,\n14:38:24.840   cmd: 'npm run tailwind:dev'\n14:38:24.841 }\n```\n\n### 3.3 在`vue.config.js`中切换nodejs版本\n\n#### 3.3.1 原本想直接`nvm use v16.14.2`，但是nvm命令找不到\n\n```\nconsole.log(\"当前nodejs版本\", process.version);\n\nexec(\"nvm use 16.14.2\", { cwd: __dirname, shell: \"/bin/bash\", }, error => {\n\tconsole.error(error);\n})\n```\n\n报错信息如下：\n\n```\n当前nodejs版本 v12.22.1\nError: Command failed: nvm use 16.14.2\n14:49:05.163 /bin/bash: nvm: command not found\n14:49:05.172     at ChildProcess.exithandler (child_process.js:308:12)\n14:49:05.172     at ChildProcess.emit (events.js:314:20)\n14:49:05.184     at maybeClose (internal/child_process.js:1022:16)\n14:49:05.185     at Socket.<anonymous> (internal/child_process.js:444:11)\n14:49:05.197     at Socket.emit (events.js:314:20)\n14:49:05.197     at Pipe.<anonymous> (net.js:675:12) {\n14:49:05.209   killed: false,\n14:49:05.212   code: 127,\n14:49:05.226   signal: null,\n14:49:05.244   cmd: 'nvm use 16.14.2'\n14:49:05.260 }\n```\n\n#### 3.3.2 `shelljs`登场\n\n> 这破烂`child_process.exec`，不折腾了，用[shelljs](https://www.npmjs.com/package/shelljs)\n\n+ vue.config.js\n```javascript\nconst shell = require('shelljs');\nconst isDev = process.env.NODE_ENV === 'development';\n\nshell.cd(__dirname);\n\t\t\n\tisDev \n\t\t? shell.exec('bash ./tailwindcss.sh development', {shell: \"/bin/bash\",async:true})\n\t\t: shell.exec('bash ./tailwindcss.sh production', {shell: \"/bin/bash\",async:true});\n\t\t\nmodule.exports = {};\n```\n\n+ 根目录新建`tailwindcss.sh`\n\n```sh\n#!/bin/bash\n\nCURRENT_NODE_ENV=$1\nDEVELOPMENT=\"development\"\n\necho \"当前NODE_ENV:\"\necho $CURRENT_NODE_ENV\n\n# 切换到当前目录\ncd $(dirname $0);\n\necho \"当前目录:\"\npwd\n\n{ # try\n \n    source ~/.nvm/nvm.sh;\n    \n    #切换nodejs版本\n    nvm use 16.14.2\n\t\n\techo \"切换后nodejs版本：\"\n\tnode -v\n    \n    if [ $CURRENT_NODE_ENV == $DEVELOPMENT ]\n    then\n    \tnpm run tailwind:dev\n    else\n    \tnpm run tailwind:prod\n    fi\n} || { # catch\n    echo \"tailwindcss 执行错误，请检查\";\n}\n\nsleep 3\n```\n\n+ 当执行Hbuilderx顶部菜单`运行 - 本地开发-测试环境接口`\n\n此时nodejs版本倒是正确切换了，tailwindcss也正确执行了，但是shell命令执行阻塞了，停留在那不继续往下执行了（HbuilderX不继续编译vue为小程序了）\n\n```\n正在编译中...\n15:19:40.696 process.env.UNI_SCRIPT: dev:mp-weixin:dev\n15:19:40.705 process.env.NODE_ENV: development\n15:19:40.706 isDev: true\n15:19:40.716 当前nodejs版本 v12.22.1\n15:19:40.766 当前NODE_ENV:\n15:19:40.766 development\n15:19:43.041 Now using node v16.14.2 (npm v8.5.0)\n15:19:43.051 切换后nodejs版本：\n15:19:43.068 v16.14.2\n15:19:43.450 > tailwind:dev\n15:19:43.461 > npx tailwindcss -i ./tailwind-input.css -o ./static/css/tailwind.css --watch\n15:19:44.696 Rebuilding...\n15:19:45.038 Done in 388ms.\n```\n\n#### 3.3.3 shell执行阻塞解决\n\n> 两种方法：\n\n+ 1 `shell.exec('bash ./tailwindcss.sh development', {shell: \"/bin/bash\", async:true})`\n\n+ 2 `shell.exec('bash ./tailwindcss.sh development &', {shell: \"/bin/bash\"})`\n\n#### 3.3.4 又遇坎坷，`uview-ui`报错\n\n> 好不容易让tailwindcss正常编译，但是项目中的uview ui又报错了，心累\n\n报错信息如下：\n```\nModule parse failed: Unexpected token (224:64)\n15:28:17.218 File was processed with these loaders:\n15:28:17.234  * ./node_modules/babel-loader/lib/index.js\n15:28:17.287  * ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader/index.js\n15:28:17.319  * ./node_modules/@dcloudio/webpack-uni-mp-loader/lib/script.js\n15:28:17.321  * ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/index.js\n15:28:17.405  * ./node_modules/@dcloudio/webpack-uni-mp-loader/lib/style.js\n15:28:17.430 You may need an additional loader to handle the result of these loaders.\n15:28:17.475 |         const grandChild = child.$children; // 判断如果在需要重新初始化的组件数组中名中，并且存在init方法的话，则执行\n15:28:17.476 | \n15:28:17.503 >         if (names.includes(child.$options.name) && typeof child?.init === 'function') {\n15:28:17.504 |           // 需要进行一定的延时，因为初始化页面需要时间\n15:28:17.530 |           uni.$u.sleep(50).then(() => {\n15:28:17.531 Module parse failed: Unexpected token (3:49)\n15:28:17.551 File was processed with these loaders:\n15:28:17.551  * ./node_modules/babel-loader/lib/index.js\n15:28:17.663  * ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader/index.js\n15:28:17.694 You may need an additional loader to handle the result of these loaders.\n15:28:17.695 | // 看到此报错，是因为没有配置vue.config.js的【transpileDependencies】，详见：https://www.uviewui.com/components/npmSetting.html#_5-cli模式额外配置\n15:28:17.714 | const pleaseSetTranspileDependencies = {},\n15:28:17.715 >       babelTest = pleaseSetTranspileDependencies?.test; // 引入全局mixin\n15:28:17.740 | \n15:28:17.891 | import mixin from './libs/mixin/mixin.js'; // 小程序特有的mixin\n```\n\n根据提示，是要在vue.config.js中添加`transpileDependencies`配置：\n\n```javascript\nmodule.exports = {\n\ttranspileDependencies: ['uview-ui']\n};\n```\n\n+ 修改后，继续执行，还是同样的报错，根据[uview ui](https://www.uviewui.com/components/install.html)文档，Hbuilderx方式安装无需再vue.config.js中添加transpileDependencies配置\n+ 删掉刚才的`transpileDependencies: ['uview-ui']`配置\n+ 难道要用uview ui提供的[npm方式](https://www.uviewui.com/components/npmSetting.html)安装吗？试了一遍，还是同样的报错，默默的撤回了修改\n\n#### 3.3.5 `uview-ui`报错的分析解决\n\n> 其实就是，tailwindcss的编译不能和HbuilderX编译小程序在同一时间执行，要错开\n> 1. 可以新开一个shell窗口执行tailwindcss编译\n> 2. 或者在子进程中执行tailwindcss编译\n> 3. 或者拿到HbuilderX编译小程序完毕后打开微信开发者工具的回调，然后再另执行tailwindcss编译\n> 4. setTimeout大法\n\n```javascript\nconst shell = require('shelljs');\nconst isDev = process.env.NODE_ENV === 'development';\n\nsetTimeout(() => {\n\tshell.cd(__dirname);\n\t\t\t\n\t\tisDev \n\t\t\t? shell.exec('bash ./tailwindcss.sh development &', {shell: \"/bin/bash\"})\n\t\t\t: shell.exec('bash ./tailwindcss.sh production', {shell: \"/bin/bash\",async:true});\n}, 30000); // 30s后执行\n\t\t\nmodule.exports = {};\n```\n\n可以看到，HbuilderX先进行了vue编译成小程序，然后tailwindcss进行监听编译，先后顺序错开，执行ok\n\n修改文件也可以生效\n```\nprocess.env.UNI_SCRIPT: dev:mp-weixin:dev\n15:43:08.945 process.env.NODE_ENV: development\n15:43:08.958 isDev: true\n15:43:08.973 当前nodejs版本 v12.22.1\n15:43:10.582 ​Browserslist: caniuse-lite is outdated. Please run:\n15:43:10.593 npx browserslist@latest --update-db​\n15:43:27.934 项目 'xxx' 编译成功。前端运行日志，请另行在小程序开发工具的控制台查看。\n15:43:27.951 正在启动微信开发者工具...\n15:43:28.941 [微信小程序开发者工具] - initialize\n15:43:28.952 [微信小程序开发者工具]\n15:43:28.953 [微信小程序开发者工具]\n15:43:29.029 [微信小程序开发者工具] ✔ IDE server has started, listening on http://127.0.0.1:59243\n15:43:29.075 [微信小程序开发者工具]\n15:43:29.092 [微信小程序开发者工具] - open IDE\n15:43:29.169 [微信小程序开发者工具]\n15:43:29.169 [微信小程序开发者工具]\n15:43:29.895 [微信小程序开发者工具] ✔ open IDE\n15:43:29.910 [微信小程序开发者工具]\n15:43:29.911 微信开发者工具已启动，在HBuilderX中修改文件并保存，会自动刷新微信模拟器\n15:43:29.932 注：\n15:43:29.961 1. 可以通过微信开发者工具切换pages.json中condition配置的页面，或者关闭微信开发者工具，然后再从HBuilderX中启动指定页面\n15:43:29.992 2. 如果出现微信开发者工具启动后白屏的问题，检查是否启动多个微信开发者工具，如果是则关闭所有打开的微信开发者工具，然后再重新运行\n15:43:30.024 3. 运行模式下不压缩代码且含有sourcemap，体积较大；若要正式发布，请点击发行菜单进行发布\n15:43:39.028 当前NODE_ENV:\n15:43:39.028 development\n15:43:42.386 Now using node v16.14.2 (npm v8.5.0)\n15:43:42.401 切换后nodejs版本：\n15:43:42.425 v16.14.2\n15:43:43.144 > tailwind:dev\n15:43:43.162 > npx tailwindcss -i ./tailwind-input.css -o ./static/css/tailwind.css --watch\n正在差量编译...\n15:45:29.429 项目 'xxx' 编译成功。前端运行日志，请另行在小程序开发工具的控制台查看。\n```\n\nsetTimeout大法虽好，但是不优雅，30s不保证HbuilderX编译vue能结束\n\n#### 3.3.6 最终版本-优雅解决`uview-ui`的报错\n\n> + 这里还是用到了`child_process.exec`子进程执行，境泽真香定律！\n> + child_process.exec执行shell可能会遇上`Permission denied`无权限执行, `chmod(u+x, /xx.sh)`解决\n\n![](../img/hbuilderx-tailwindcss/zx.png)\n\n```javascript\nconst path = require(\"path\");\nconst shell = require('shelljs');\nconst {exec} = require('child_process');\n\nconsole.log(\"process.env.UNI_SCRIPT:\", process.env.UNI_SCRIPT);\nconsole.log(\"process.env.NODE_ENV:\", process.env.NODE_ENV);\n\nconst isDev = process.env.NODE_ENV === 'development';\n\nconsole.log(\"isDev:\", isDev);\nconsole.log(\"当前nodejs版本\", process.version);\n\nfunction executeTailWindCssSh() {\n\t// https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback\n\texec(\n\t\tisDev ? '\"./tailwindcss.sh\" development' : '\"./tailwindcss.sh\" production',\n\t\t{ cwd: __dirname, shell: \"/bin/bash\", },\n\t\t(error, stdout, stderr) => {\n\t\t\tif (error) {  \n\t\t\t\tconsole.error('[tailwindcss error]', error);\n\t\t\t\tconsole.error(\"error.stderr:\", stderr);\n\t\t\t\t\n\t\t\t\tif(stderr && stderr.includes(\"Permission denied\")) {\n\t\t\t\t\t// 给当前user增加运行文件权限\n\t\t\t\t\tshell.chmod(\"u+x\", path.resolve(__dirname, './tailwindcss.sh'));\n\t\t\t\t\t\n\t\t\t\t\texecuteTailWindCssSh();\n\t\t\t\t}\n\t\t\t} \n\t\t\t\n\t\t\tisDev ? console.log(`[tailwindcss stdout]: ${stdout}`)\n\t\t\t\t: console.log('[tailwindcss] 生产环境打包完成');\n\t\t}\n\t);\n}\n\nexecuteTailWindCssSh();\n\nmodule.exports = {};\n```\n\n## 4.参考资料\n\n1. [Hbuilder创建的uniapp工程，使用tailwindcss最优雅的方式](https://ask.dcloud.net.cn/article/40098)\n\n2. [shelljs](https://www.npmjs.com/package/shelljs)\n\n3. [child_process.exec](https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback)\n\n4. [Tailwind CLI](https://www.tailwindcss.cn/docs/installation)\n\n------\n\n![img](../img/gzh/gzh_qrcode.jpg)\n"},{"id":"PIPYfZPPpPmte6mJ8DLVq","title":"React Native Android 端Headless JS后台 GPS 持续定位","keywords":["react"," react native"," 持续定位"],"date":"2023-07-12","fileName":"react-native-headless-js","content":"\n![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/Az6S7PrZXXaxouNtoZdmd8DYB1IgRDRYLFXMuHrU4yw1t0ia1Iuz8TTAzbvibzxvlDW3s8ZBgBicsAQibB9fdlPtxQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)\n\n- [本文 github 仓库链接](https://github.com/sRect/reactNativeBlogApp/commit/f328f51c9686da68d04c24bdaa43ef0ffe73b332)\n- [本文掘金链接](https://juejin.cn/post/7254811625055944762)\n\n## 1. 写在前面\n\n有J友在掘金私信我，react native android中，app在后台如何持续获取位置信息，还有headless js中setTimeout没有按预期执行两个问题。问我有什么解决方法，当时我就懵逼了，这不是触及到我装X盲区了吗，况且我只是js菜鸡，不会android，难受！\n\n## 2. 本文主要 package version\n\n| package                             | version |\n| ----------------------------------- | :-----: |\n| react                               | 18.2.0  |\n| react-native                        | 0.71.2  |\n| @react-native-community/geolocation | ^3.0.5  |\n\n- 当前react native最新版本是v0.72\n\n## 3. 前置基础\n\n1. React 基础\n2. [React Native Android 原生模块](https://www.reactnative.cn/docs/native-modules-android)，已经跟着文档，在js中调用android暴露的方法\n\n## 4. 初步了解Headless JS\n\n> [Headless JS文档](https://www.reactnative.cn/docs/headless-js-android)\n\n1. Headless JS 是一种使用 js 在后台执行任务的方法。它可以用来在后台同步数据、处理推送通知或是播放音乐等等。\n\n2. 可以在任务中处理任何事情（网络请求、定时器等），但**`不要涉及UI界面`**\n\n3. `The function passed to setTimeout does not always behave as expected. Instead the function is called only when the application is launched again. If you just need to wait, use the retry functionality`，文档这里已经说明，headless js中`setTimeout`不会按预期执行，而是会在app再次启动的时候才执行(就是app切到后台时，不会执行，切回前台的时候才执行)，那用什么代替setTimout呢？下面会讲到。\n\n4. Headless JS中发起网络请求，经过实际测试，完全没问题的\n\n5. 还有，**app进程被杀掉(人为主动杀掉和系统资源优化掉)，Headless JS后台任务也会停止**，这里不讨论进程被杀掉还能继续执行后台任务\n\n## 5. 使用Headless JS的姿势\n\n> 在[React Native 练习时长 2 月半，踩坑总结](https://juejin.cn/post/7234407587118530597#heading-25)文章中有涉及到使用Headless JS后台播放raw本地音频文件，那里是使用`AppRegistry.startHeadlessTask(taskId, taskKey, data)`api开始后台任务的，在官方文档中有提到在`service`中启动，但是步骤都不是非常详细\n\n### 5.1 使用`AppRegistry.startHeadlessTask` api启动Headless js后台任务\n\n具体步骤，详见[这篇文章-7.4章节app后台播放音频示例步骤](https://juejin.cn/post/7234407587118530597#heading-29)，每一步都很详细，对着步骤来。\n\n### 5.2 通过`android WorkManager`中调用`services`，启动Headless js后台任务\n\n> 怎么突然又冒出来`WorkManager`了？没办法啊，按着文档那种方式来，Headless JS中代码不执行，下面步骤1代码中会提到\n\n`WokerManager`是什么？\n\n[`WorkManager is the recommended way to perform background tasks in Android. WorkManager can schedule one-time or periodic tasks in a simple, reliable way.`](https://blog.logrocket.com/run-react-native-background-tasks-headless-js/)\n\n意思就是说，WorkManager是android中推荐执行后台任务的方式，可以执行一次性任务和定时任务。\n\n1. `android/app/src/main/java/com/your-app-name/BackgroundPosition.java`\n\n```java\npackage com.your-app-name;\n\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.WritableMap;\nimport com.facebook.react.bridge.Arguments;\nimport com.facebook.react.modules.core.DeviceEventManagerModule;\nimport android.content.Context;\nimport android.app.ActivityManager;\n\nimport androidx.work.ExistingPeriodicWorkPolicy; \nimport androidx.work.PeriodicWorkRequest;\nimport androidx.work.WorkManager;\n\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.List;\nimport javax.annotation.Nullable;\nimport java.util.concurrent.TimeUnit;\n\npublic class BackgroundPosition extends ReactContextBaseJavaModule {\n  private static ReactApplicationContext reactContext;\n  private Timer timer = null;//计时器\n  private TimerTask task = null;\n  // private LocationManager locationManager; \n  // private LocationListener locationListener; \n  private PeriodicWorkRequest workRequest;\n  private static final String TAGERROR = \"START_BACKGROUND_TASK_ERROR\";\n\n  public BackgroundPosition(ReactApplicationContext context) {\n    super(context);\n    reactContext = context;\n\n    workRequest = new PeriodicWorkRequest.Builder(BackgroundPositionWorker.class, 15, TimeUnit.MINUTES).build();\n  }\n\n  @Override\n  public String getName() {\n    return \"BackgroundPosition\";\n  }\n\n  private void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) {\n    reactContext\n        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n        .emit(eventName, params);\n  }\n\n  @ReactMethod\n  public void addListener(String eventName) {\n    // Set up any upstream listeners or background tasks as necessary\n  }\n  @ReactMethod\n  public void removeListeners(Integer count) {\n    // Remove upstream listeners, stop unnecessary background tasks\n  }\n\n  private boolean isAppOnForeground(Context context) {\n    /**\n      我们需要先检查应用当前是否在前台运行，否则应用会崩溃。\n      http://stackoverflow.com/questions/8489993/check-android-application-is-in-foreground-or-not\n    **/\n    ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n    List<ActivityManager.RunningAppProcessInfo> appProcesses =\n    activityManager.getRunningAppProcesses();\n    if (appProcesses == null) {\n        return false;\n    }\n    final String packageName = context.getPackageName();\n    for (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) {\n        if (appProcess.importance ==\n        ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND &&\n          appProcess.processName.equals(packageName)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  @ReactMethod\n  public void startBackgroudTask(Promise promise) {\n    if(timer!=null) {\n      timer.cancel();\n      timer=null;\n    }\n\n    timer = new Timer();\n    task = new TimerTask() {\n      @Override\n      public void run() {\n        try {\n          if(!isAppOnForeground(reactContext)) {\n            WritableMap params = Arguments.createMap();\n            params.putString(\"msg\", \"app已经在后台了，准备启动BackgroundPostionWorker\");\n            sendEvent(reactContext, \"backgroundTask\", params);\n\n            // 上面讲到为什么要冒出来WorkManager，就是因为这里\n            // 直接在js中调用startBackgroudTask，执行reactContext.startService(service)\n            // 但是headless js中的任务不执行\n            // 所以这里通过WorkManager开始一个work任务，然后在work中启动startService\n\n            // Intent service = new Intent(reactContext, BackgroundPositionServices.class);\n            // // service.putExtra(\"backgroundTask\", \"123\");\n            // // reactContext.startService(service);\n\n            // Bundle bundle = new Bundle();\n            // bundle.putString(\"foo\", \"bar\");\n            // service.putExtras(bundle);\n\n            // // if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            // //   reactContext.startForegroundService(service);\n            // // } else {\n            // //   reactContext.startService(service);\n            // // }\n\n            // reactContext.startService(service);\n            // // HeadlessJsTaskService.acquireWakeLockNow(reactContext);\n\n            WorkManager.getInstance().enqueueUniquePeriodicWork(\"BackgroundPositionWorker\", ExistingPeriodicWorkPolicy.KEEP, workRequest);\n\n            WritableMap params2 = Arguments.createMap();\n            params2.putString(\"msg\", \"BackgroundPostionWorker started\");\n            promise.resolve(params2);\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          promise.reject(TAGERROR, e);\n        }\n      }\n    };\n    // 3s后执行1次\n    timer.schedule(task, 3000);\n  }\n\n  @ReactMethod\n  public void stopBackgroudTask(Promise promise) {\n    if(timer!=null) {\n      timer.cancel();\n      timer=null;\n    }\n\n    // if(locationManager != null && locationListener != null) {\n    //   locationManager.removeUpdates(locationListener);\n    // }\n    WritableMap params = Arguments.createMap();\n    params.putString(\"msg\", \"BackgroundPostionWorker stop successed\");\n\n    WorkManager.getInstance().cancelUniqueWork(\"BackgroundPositionWorker\");\n    promise.resolve(params);\n  }\n}\n```\n\n2. `android/app/src/main/java/com/your-app-name/BackgroundPositionPackage.java`\n\n```java\npackage com.your-app-name;\n\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.uimanager.ViewManager;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class BackgroundPositionPackage implements ReactPackage {\n\n  @Override\n  public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {\n    return Collections.emptyList();\n  }\n\n  @Override\n  public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {\n    List<NativeModule> modules = new ArrayList<>();\n\n    modules.add(new BackgroundPosition(reactContext));\n\n    return modules;\n  }\n}\n```\n\n3. `android/app/src/main/java/com/your-app-name/MainApplication.java`\n\n```diff\n+ import com.your-app-name.BackgroundPositionPackage;\n\npublic class MainApplication extends Application implements ReactApplication {\n    ...\n    @Override\n    protected List<ReactPackage> getPackages() {\n      @SuppressWarnings(\"UnnecessaryLocalVariable\")\n      List<ReactPackage> packages = new PackageList(this).getPackages();\n\n+     packages.add(new BackgroundPositionPackage());// <-- 添加这一行，类名替换成你的Package类的名字 name.\n      return packages;\n    }\n    ...\n}\n```\n\n4. `android/app/src/main/java/com/your-app-name/BackgroundPositionServices.java`\n\n```java\npackage com.your-app-name;\n\nimport android.content.Intent;\nimport android.os.Bundle;\nimport com.facebook.react.HeadlessJsTaskService;\nimport com.facebook.react.bridge.Arguments;\nimport com.facebook.react.jstasks.HeadlessJsTaskConfig;\nimport com.facebook.react.bridge.WritableMap;\nimport com.facebook.react.jstasks.HeadlessJsTaskRetryPolicy;\nimport com.facebook.react.jstasks.LinearCountingRetryPolicy;\n\nimport javax.annotation.Nullable;\n\npublic class BackgroundPositionServices extends HeadlessJsTaskService {\n  @Override\n  protected @Nullable HeadlessJsTaskConfig getTaskConfig(Intent intent) {\n    Bundle extras = intent.getExtras();\n    WritableMap data = extras != null ? Arguments.fromBundle(extras) : Arguments.createMap();\n    // https://github.com/eduardomota/smsgate/blob/803f775ae419db2aea63aeac5def15eb0ec28542/smsrelay2/android/app/src/main/java/com/smsrelay2/SmsEventService.java\n    LinearCountingRetryPolicy retryPolicy = new LinearCountingRetryPolicy(\n      3, // Max number of retry attempts\n      1000 // Delay between each retry attempt\n    );\n\n    // if (extras != null) {\n    //   return new HeadlessJsTaskConfig(\n    //       \"BackgroundTask\",\n    //       Arguments.fromBundle(extras),\n    //       5000, // 任务的超时时间\n    //       false // 可选参数：是否允许任务在前台运行，默认为false\n    //     );\n    // }\n\n    return new HeadlessJsTaskConfig(\n      \"BackgroundPosition\",\n      data,\n      10000, // 任务的超时时间\n      false, // 可选参数：是否允许任务在前台运行，默认为false\n      retryPolicy\n    );\n  }\n}\n```\n\n5. `android/app/src/main/java/com/your-app-name/BackgroundPositionWorker.java`\n\n```java\npackage com.your-app-name;\n\nimport androidx.annotation.NonNull;\nimport androidx.work.Worker; \nimport androidx.work.WorkerParameters;\n\nimport android.os.Bundle;\nimport android.content.Intent;\nimport android.content.Context;\n\npublic class BackgroundPositionWorker extends Worker {\n    public BackgroundPositionWorker(\n        @NonNull Context context, \n        @NonNull WorkerParameters workerParams) {\n        super(context, workerParams);\n    }\n\n    @NonNull\n    @Override\n    public Result doWork() {\n        Intent service = new Intent(getApplicationContext(), BackgroundPositionServices.class);\n        Bundle bundle = new Bundle();\n        bundle.putString(\"msg\", \"backgroundPosition start\");\n        service.putExtras(bundle);\n        getApplicationContext().startService(service);\n        return Result.success();\n    }\n}\n```\n\n6. `android/app/src/main/AndroidManifest.xml`中添加权限\n\n```xml\n...\n+ <!-- 精确定位 -->\n+ <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n+ <!-- 模糊定位 -->\n+ <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n+ <!-- 后台定位 -->\n+ <uses-permission android:name=\"android.permission.ACCESS_BACKGROUND_LOCATION\" />\n<application> \n    ... \n    + <service android:name=\"com.your-app-name.BackgroundPositionServices\" /> \n</application>\n```\n\n7. `index.js`中注册后台任务\n\n```diff\nimport {AppRegistry} from 'react-native';\nimport App from './App';\nimport {name as appName} from './app.json';\n+ import {backgroundPosition} from './src/utils';\n\nAppRegistry.registerComponent(appName, () => App);\n+ AppRegistry.registerHeadlessTask('BackgroundPosition', () => backgroundPosition);\n```\n\n8. `src/utils/backgroundPosition.js`后台任务具体代码\n\n+ 这里使用`@react-native-async-storage/async-storage`的`Geolocation.watchPosition`来监测位置变化，您也可以在android中开启一个定时任务，然后发送位置给js端\n\n+ 刚开始没注意到有`watchPosition`这个api，定时执行`Geolocation.getCurrentPosition`这个api来获取，当app切换到后台时，没看到手机顶部位置有定位图标，而`watchPosition`这个api执行的时候，app在后台的时候，手机顶部有定位图标，就和使用百度地图时一样。\n\n+ 这里将gps位置通过[`@react-native-async-storage/async-storage`](https://react-native-async-storage.github.io/async-storage/docs/api/#clear)存储在本地\n\n+ gps位置坐标google地图可以直接使用，而要在高德或者百度地图中使用要转换，怎么转换，可以使用[高德坐标转换](https://link.juejin.cn/?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fwebservice%2Fguide%2Fapi%2Fconvert)，或者[GPS坐标转高德地标（火星坐标/国测坐标）脚本转换](https://www.jianshu.com/p/dd0c017250e4)\n\n+ 或者这里干脆就使用其他模块，直接获取高德或者百度地图坐标，例如[`react-native-amap-geolocation`](https://www.npmjs.com/package/react-native-amap-geolocation)，但这个库我没测试使用过\n\n```javascript\nimport {InteractionManager, AppState, NativeModules} from 'react-native';\nimport Geolocation from '@react-native-community/geolocation';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport dayjs from 'dayjs';\n\nconst BackgroundPosition = NativeModules.BackgroundPosition;\n\nfunction handleListenerAppState(watchId = 0) {\n  const subscription = AppState.addEventListener('change', nextAppState => {\n    console.log('nextAppState', nextAppState);\n    if (nextAppState === 'active') {\n      flag = false;\n      console.log('app回到前台，后台任务停止');\n      console.log('watchId:', watchId);\n      BackgroundPosition.stopBackgroudTask();\n      Geolocation.clearWatch(watchId);\n      subscription.remove();\n    }\n  });\n}\n\nexport async function backgroundPosition(e) {\n  await AsyncStorage.clear();\n\n  const handle = InteractionManager.createInteractionHandle();\n  InteractionManager.runAfterInteractions(() => {\n    // ...需要长时间同步执行的任务...\n    // getCurrentPosition();\n    let watchPositionId = Geolocation.watchPosition(\n      async info => {\n        const {\n          coords: {latitude, longitude},\n        } = info;\n        console.log('当前位置：', latitude, longitude);\n\n        let locationListStr = await AsyncStorage.getItem('location');\n        let locationObj =\n          locationListStr === null ? {list: []} : JSON.parse(locationListStr);\n        locationObj.list.push({\n          latitude,\n          longitude,\n          date: dayjs().format('YYYY-MM-DD HH:mm:ss'),\n        });\n\n        await AsyncStorage.setItem('location', JSON.stringify(locationObj));\n      },\n      err => {\n        console.warn('获取定位失败==>', err);\n      },\n      {\n        interval: 5000, // 每5s更新一次位置\n        timeout: 10000, // 获取一个位置，10s钟超时\n        maximumAge: 15000, // 可能缓存位置的最长时间(以毫秒为单位)\n        enableHighAccuracy: true, // 使用GPS\n        distanceFilter: 1, // 返回一个新位置之前，与前一个位置的最小距离。设置为0表示不过滤位置。默认为100m。\n        // useSignificantChanges?: boolean; // 只有当设备检测到一个重要的距离已经被突破时，才会返回位置。默认为FALSE。\n      },\n    );\n    console.log('watchPositionId:', watchPositionId);\n    handleListenerAppState(watchPositionId);\n  });\n\n  InteractionManager.clearInteractionHandle(handle);\n  // return await Promise.resolve();\n}\n```\n\n9. 页面UI中点击某按钮执行后台任务\n\n+ Android 10（API 级别 29）中，新增了ACCESS_BACKGROUND_LOCATION后台权限\n\n+ 在android 11级以上版本需要先申请ACCESS_COARSE_LOCATIO和ACCESS_FINE_LOCATION后, 再申请ACCESS_BACKGROUND_LOCATION权限，才能确保前台访问位置权限和后台访问位置权限正常\n\n+ 如果同时申请这三个权限时不会弹窗，系统会忽略权限请求，不会授予其中的任一权限。\n\n```javascript\nconst BackgroundPosition = NativeModules.BackgroundPosition;\n// 申请定位权限\nconst handleAndroidPositionPermission = async () => {\n  try {\n    // https://juejin.cn/post/7058265721540706311\n    // android 11及以上版本申请权限时系统对话框不存在始终允许的选项，并且只能够在系统设置页面打开后台权限。\n\n    const granted1 = await PermissionsAndroid.requestMultiple([\n      PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,\n      PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION,\n    ]);\n\n    const granted2 = await PermissionsAndroid.request(\n      PermissionsAndroid.PERMISSIONS.ACCESS_BACKGROUND_LOCATION,\n    );\n\n    if (\n      granted1['android.permission.ACCESS_FINE_LOCATION'] ===\n        PermissionsAndroid.RESULTS.GRANTED &&\n      granted1['android.permission.ACCESS_COARSE_LOCATION'] ===\n        PermissionsAndroid.RESULTS.GRANTED &&\n      granted2 === PermissionsAndroid.RESULTS.GRANTED\n    ) {\n      console.log('可以定位了');\n      return Promise.resolve();\n    } else {\n      console.log('拒绝获取定位权限');\n      Toast.fail({\n        content: \"拒绝获取定位权限\",\n        duration: 2,\n        stackable: true,\n      });\n      return Promise.reject({msg: '拒绝获取定位权限'});\n    }\n  } catch (error) {\n    console.warn(error);\n    return Promise.reject();\n  }\n};\n\nconst handleBackgroundTask = async type => {\n  // 点击按钮后，将app切换到后台，即可执行后台任务，\n  // 或者这里通过AppState监听，app在后台，自动执行后台任务\n  try {\n    if (type === 'start') {\n      // 申请定位权限\n      await handleAndroidPositionPermission();\n      // 开始后台任务\n      await BackgroundPosition.startBackgroudTask();\n    } else {\n      // 结束后台任务\n      await BackgroundPosition.stopBackgroudTask();\n    }\n  } catch (error) {\n    console.error('handleBackgroundTask error', error);\n  }\n};\n```\n\n## 6. 实际测试结果和存在的问题\n\n> 测试机型小米10，android13\n\n1. 开启后台任务后，手机锁屏，执行20分钟后，app被系统自己杀掉了，如果是在持续玩手机，app没被系统杀掉，可能和手机的省电策略有关；\n2. 坐标保存不是很多，甚至出现中途有20分钟没保存坐标，不知道什么原因；\n3. 保存的gps坐标，在google地图上和活动轨迹大概吻合，但是误差有点大；\n4. 可能是`@react-native-async-storage/async-storage`的`watchPosition`有问题，需要自定义一个实时获取坐标的安卓原生模块对比测试下\n\n## 7. 关于在Headless JS中如何执行`setTimeout`?\n\nISSUE里搜了下，也没什么关键信息，甚至显示有人已经提交过PR了\n![](https://mmbiz.qpic.cn/sz_mmbiz_png/Az6S7PrZXXaxouNtoZdmd8DYB1IgRDRY6XGZPF4y0icPhkRCJIb5hZOQosEtMQDZEbiahA87vIE4s4FHf3y5agUA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1. 那使用`requestAnimationFrame`呢？经过实际测试，有时候执行，有时候不执行\n\n2. `setInterval`和`setImmediate`也不行\n\n3. 使用while循环，自己实现一个setTimeout，配合递归，经过实际测试，可行\n\n```javascript\nconst sleep = function (startTime, delay) {\n  return () => {\n    let cur = new Date().getTime();\n    while (cur < startTime + delay) {\n      cur = new Date().getTime();\n    }\n  };\n};\n\nfunction fun() {\n  // ...\n  sleep(new Date().getTime(), 3000)(); // 3S后递归执行下面fun方法\n  fun();\n}\n```\n\n## 8. 参考资料\n\n1. [headless-js中文文档](https://www.reactnative.cn/docs/headless-js-android)\n2. [Run React Native background tasks with Headless JS](https://blog.logrocket.com/run-react-native-background-tasks-headless-js/)\n3. [使用android WorkManager的React Native HeadlessJs任务调用](https://www.qiniu.com/qfans/qnso-65547466)\n4. [How to Run a Background Task in React Native ?](https://medium.com/the-sixt-india-blog/how-to-run-a-background-task-in-react-native-cd4d36e40bf)\n5. [android位置权限的变更史](https://juejin.cn/post/7058265721540706311)\n\n------\n\n![img](../img/gzh/gzh_qrcode.jpg)\n\n"},{"id":"1g3jqIly9cmfeY7jURUUQ","title":"React Native 练习时长 2 月半，踩坑总结","keywords":["react"," react native"],"date":"2023-05-23","fileName":"react-native","content":"\n- [本文 github 仓库链接](https://github.com/sRect/reactNativeBlogApp)\n- [本文掘金链接](https://juejin.cn/post/7234407587118530597)\n\n> 2023 年了，RN 也凉的差不多了。本文用 react native 做的 app 很简单，首页 + 列表页 + 详情页 + 关于页。总的感觉，涉及到原生方面，对于不会 android 和 ios 的 js 菜鸡，比较棘手，要折腾。\n\n![](https://mmbiz.qpic.cn/sz_mmbiz_gif/Az6S7PrZXXZSPkKoic0VcqUCDcBGZZNcp4TOrMtOzQENFzer4t5qCmcwibdTGD6WyVFOmibjktsUp6g5HxS3Jicf4A/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1)\n\n## 1. 前置基础\n\n1. React 基础\n2. [React Native 文档](https://www.reactnative.cn/)\n\n## 2. 本文主要 package version\n\n> 1. 这里页面路由应该使用 [`react-navigation`](https://reactnavigation.org/docs/getting-started) 更方便些，react-router-native6.x 版本感觉对 react native 支持不是很好\n> 2. 对于 UI 库，没找到合适的，找了一个老掉牙的[`ant-design-react-native`](https://rn.mobile.ant.design/docs/react/introduce-cn)\n\n| package                  | version  |\n| ------------------------ | :------: |\n| react                    |  18.2.0  |\n| react-native             |  0.71.2  |\n| react-router-native      |  ^6.8.0  |\n| react-native-webview     | ^11.26.1 |\n| @ant-design/react-native |  ^5.0.3  |\n\n## 3. 关于 React Native 的一些疑问\n\n### 3.1 React Native 和 Flutter 优缺点对比\n\n> 来自 chat gpt 的回答，感觉有些落后啊\n\n|              |                                                          优点                                                           | 缺点                                                                                                                                    |\n| ------------ | :---------------------------------------------------------------------------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------- |\n| React Native |   1. 拥有大量第三方库和社区支持；<br>2. 可以复用 React 的开发经验,语法上非常接近 React；<br> 3. 支持热重载,开发效率高   | 1. 部署和打包过程较复杂；<br>2. 动画和性能体验略逊色于原生；<br>3. 升级过程可能会比较痛苦                                               |\n| Flutter      | 1. 组件丰富,UI 体验接近原；<br>2. 性能很高,特别是动画方面；<br> 3. 打包简单,可以编译成原生代码；<br>4. 升级过程比较顺畅 | 1. 第三方库和社区还在发展,不如 React Native 成熟 ；<br>2. 对 Dart 语言的依赖,有一定学习成本；<br> 3. 热重载不能像 React Native 一样方便 |\n\n### 3.2 如何看待 react native 到目前为止，还没出 1.0 版本？\n\n> 同样来自 chat gpt 的回答\n\nReact Native 虽然至今还没发布 1.0 版本,但这不意味着它不成熟或不可用。\n\n1. Facebook 的版本发布策略是非常慢慢的,要达到 1.0 需要非常稳定和完善,这需要长期的迭代和磨合。\n2. React Native 生态庞大,涉及的平台和版本组合非常多,要保证在所有环境下 100% 稳定并不容易。\n3. React Native 的升级过程中,会涉及到原生代码的迁移,这也增加了版本发布的难度。\n4. 社区提供的第三方库也需要跟上版本迭代,这需要协调和校准,也是版本发布的阻碍。\n\n### 3.3 react native 使用的是原生 view 还是 webview?\n\n> 同样来自 chat gpt 的回答\n\n- React Native 使用的是原生 View 而不是 WebView\n- React Native 的核心思想是使用 JavaScript 来开发移动应用,而不是 Web 应用。它允许你使用 React 来开发原生移动应用,最终编译成真实的原生 UI 元素\n- 具体来说,React Native 将 React 组件映射到原生 View 和 Text 组件上,而不是 WebView。所以当你在 JavaScript 中构建一个 Button 时,在本质上它会变成 Android 的 Button 或 iOS 的 UIButton。\n\n## 4. 开发环境准备\n\n> 本文选择了本地搭建环境，没有选择依赖线上的 expo 沙盒环境\n\n[本地环境搭建文档](https://www.reactnative.cn/docs/environment-setup)，对着文档一步步来即可\n\n1. 创建项目\n\n```\nnpx react-native init AwesomeProject\n```\n\n2. 使用安卓手机调试\n\n> 也可以使用模拟器，由于我手机是安卓的，就用了安卓手机。还有就是安卓模拟器上的显示和真机有些差距，问题没及时暴露。\n\n手机打开开发者模式，并打开 usb 调试，数据线连接电脑即可，运行项目的时候，会自动在你的手机上安卓 debug 安装包\n\n## 5. 开发时遇到的一些问题总结\n\n### 5.1 安装第三方 ui 库，link 字体时报错\n\n> 根据 Ant Design Mobile RN of React 文档[链接字体图标](https://rn.mobile.ant.design/docs/react/introduce-cn)，安装完`@ant-design/icons-react-native`库后，需要执行`npx react-native link @ant-design/icons-react-native`，然后出现如下报错\n\n![](https://mmbiz.qpic.cn/sz_mmbiz_png/Az6S7PrZXXZSPkKoic0VcqUCDcBGZZNcpqAZFa0q4ia1pPGGUGicg7liasYDdSa1bc2VJ40fqXTgkUCnsRqPQMkGwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**解决：**\n\n1. 安装 `react-native-asset`\n\n```\nyarn add react-native-asset --save\n```\n\n2. 根目录 react-native.config.js，assets 添加字体图标文件的路径\n\n```\nmodule.exports = {\n  assets: ['node_modules/@ant-design/icons-react-native/fonts']\n};\n```\n\n3. 执行 yarn react-native-asset\n\n```\nyarn react-native-asset\n```\n\n4. 检查是否链接成功，android\\app\\src\\main\\assets 下是否有 fonts 文件夹\n\n![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/Az6S7PrZXXZSPkKoic0VcqUCDcBGZZNcpkn0mkicue4DOE5b7JWqBYkF6zr3dYrRnFzLiaHBCqGQUq1xrluUiaxTPQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### 5.2 如何像 web 项目一样使用 env 环境变量？\n\n> 如何像 web 项目一样，本地开发使用`.env.development`文件，生产打包的时候使用`.env.production`文件，`.env.local`文件只在本地生效？\n\n1. 安装[`react-native-config`](https://github.com/luggit/react-native-config)及配置步骤\n\n- 安装\n\n```\nyarn add react-native-config\n```\n\n- android/settings.gradle\n\n```diff\n+ include ':react-native-config'\n+ project(':react-native-config').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-config/android')\n```\n\n- android/app/build.gradle\n\n```diff\nandroid {\n    // project.ext.defaultEnvFile = \"path/to/.env.file\"\n    // 写在 apply from: project(':react-native-config').projectDir.getPath() + \"/dotenv.gradle\" 这行之前\n+    project.ext.envConfigFiles = [\n+      debug: \".env.development\",\n+      release: \".env.production\"\n+    ]\n\n    defaultConfig {\n        applicationId \"com.xxx.xxx\"\n        minSdkVersion rootProject.ext.minSdkVersion\n        targetSdkVersion rootProject.ext.targetSdkVersion\n        versionCode 2\n        versionName \"0.0.2\"\n        // for react-native-config\n+        resValue \"string\", \"build_config_package\", \"com.xxx.xxx\"\n    }\n}\n\ndependencies {\n    implementation \"com.facebook.react:react-native:+\"  // From node_modules\n+    implementation project(':react-native-config')\n}\n\n// 最后一行添加\n+ apply from: project(':react-native-config').projectDir.getPath() + \"/dotenv.gradle\"\n```\n\n- android/app/src/main/java/com/your-app-name/MainApplication.java\n\n```diff\n+ import com.lugg.RNCConfig.RNCConfigPackage;\n```\n\n2. package.json 中 添加 scripts 脚本命令\n\n`.env.local`加入到`.gitignore`文件中忽略，文件中可以放入一些私有敏感变量，不会被提交到仓库里；\n\n本地开发和生产打包时将`.env.local`文件里的变量复制到`.env.development`或`.env.production`文件里，启动项目完成或者打包完后，再将新复制进来的变量删除；\n\n这样就解决了 debug 和 release 变量区分，而本地私有变量也不会直接暴露出去。\n\n- 新建.env.local 文件\n\n```\n# 高德地图key\n# android\nAMP_ANDROID_API_KEY=xxx\n```\n\n- 新建.env.development 文件\n\n```\nNODE_ENV=development\nBASE_URL=https://xxx.dev.api.com\nMY_VARIABLE_ENV=123dev\n```\n\n- 新建.env.production 文件\n\n```\nNODE_ENV=production\nBASE_URL=https://xxx.prod.api.com\nMY_VARIABLE_ENV=123prod\n```\n\n- package.json\n\n```json\n{\n  \"scripts\": {\n    \"preandroid\": \"node ./scripts/checkEnvAmapKey .env.local && cat .env.local >> .env.development\",\n    \"android\": \"ENVFILE=.env.development react-native run-android\",\n    \"postandroid\": \"node ./scripts/revertEnvFile .env.development .env.local\",\n    \"prebuild:android\": \"node ./scripts/checkEnvAmapKey .env.local && cat .env.local >> .env.production\",\n    \"build:android\": \"cd android && ENVFILE=.env.production ./gradlew assembleRelease\",\n    \"postbuild:android\": \"node ./scripts/revertEnvFile .env.production .env.local\",\n    \"prebuild:android:aab\": \"node ./scripts/checkEnvAmapKey .env.local && cat .env.local >> .env.production\",\n    \"build:android:aab\": \"cd android && ENVFILE=.env.production ./gradlew bundleRelease\",\n    \"postbuild:android:aab\": \"node ./scripts/revertEnvFile .env.production .env.local\"\n  }\n}\n```\n\n- scripts/checkEnvAmapKey.js\n\n```javascript\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst { Buffer } = require(\"buffer\");\nconst argv = process.argv.slice(2);\nconst rootDir = process.cwd();\nconst fsPromise = fs.promises;\nconst chalk = require(\"chalk\");\n// const shell = require('shelljs');\n\nconsole.log(\"argv:\", argv); // [ '.env.development', '.env.local' ]\n\nconst envLocalFilePath = path.resolve(rootDir, `./${argv[0]}`);\nconst envLocalFileTemplate = `\n# 高德地图key\n# android\nAMP_ANDROID_API_KEY=请输入您的android api key\n`;\n\nconst handleWrite = async () => {\n  try {\n    // https://nodejs.org/docs/latest-v16.x/api/fs.html#fspromiseswritefilefile-data-options\n    const controller = new AbortController();\n    const { signal } = controller;\n    const data = new Uint8Array(Buffer.from(envLocalFileTemplate));\n\n    const promise = await fsPromise.writeFile(envLocalFilePath, data, {\n      signal,\n      encoding: \"utf8\",\n      flags: \"w\", // 以写入模式打开文件，如果文件不存在则创建\n    });\n\n    // Abort the request before the promise settles.\n    controller.abort();\n\n    await promise;\n  } catch (error) {\n    console.log(chalk.red(\"写入文件失败\"), error);\n  } finally {\n    process.exit(1);\n  }\n};\n\nasync function writeEnvAmapKeyFile() {\n  // https://nodejs.org/docs/latest-v16.x/api/fs.html#fsexistspath-callback\n  fs.open(envLocalFilePath, \"wx\", async (err, fd) => {\n    if (err) {\n      if (err.code === \"EEXIST\") {\n        console.log(`${envLocalFilePath}文件已存在`);\n      }\n      process.exit(1);\n      return;\n    }\n\n    try {\n      await handleWrite();\n    } finally {\n      fs.close(fd, (error) => {\n        if (error) {\n          throw error;\n        }\n      });\n      process.exit(1);\n    }\n  });\n}\n\n// 检查本地根目录是否存在`.env.local`文件\nasync function checkEnvAmapKeyFile() {\n  try {\n    await fsPromise.stat(envLocalFilePath);\n    console.log(`${chalk.green(\"项目根目录已存在 `.env.local` 文件\")};`);\n  } catch (error) {\n    console.log(`\n      ${chalk.red.bgYellow(\"项目根目录不存在 `.env.local` 文件，将进行创建\")};\n      ${chalk.yellow(\n        \"请在生成的`.env.local`文件中填入高德地图API KEY，未申请的请前往高德地图 https://console.amap.com/dev/key/app 中申请创建，申请成功后，请复制key到 `.env.local`文件相应位置，然后重新启动项目\"\n      )}\n    `);\n\n    // shell.exec('touch \\\\.env.local');\n    await writeEnvAmapKeyFile();\n  }\n}\n\ncheckEnvAmapKeyFile();\n```\n\n- scripts/revertEnvFile.js\n\n```javascript\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst { Buffer } = require(\"buffer\");\nconst argv = process.argv.slice(2);\nconst rootDir = process.cwd();\nconst fsPromise = fs.promises;\nconst chalk = require(\"chalk\");\n\nconsole.log(\"argv:\", argv); // [ '.env.development', '.env.local' ]\n\nconst envLocalFilePath = path.resolve(rootDir, `./${argv[1]}`);\nconst envFilePath = path.resolve(rootDir, `./${argv[0]}`);\n\nconst handleWrite = async (filePath, data) => {\n  try {\n    // https://nodejs.org/docs/latest-v16.x/api/fs.html#fspromiseswritefilefile-data-options\n    const controller = new AbortController();\n    const { signal } = controller;\n    const str = new Uint8Array(Buffer.from(data));\n    const promise = await fsPromise.writeFile(filePath, str, {\n      signal,\n      encoding: \"utf8\",\n      flags: \"w\", // 以写入模式打开文件，如果文件不存在则创建\n    });\n\n    // Abort the request before the promise settles.\n    controller.abort();\n\n    await promise;\n  } catch (error) {\n    console.log(chalk.red(\"写入文件失败\"), error);\n  } finally {\n    process.exit(1);\n  }\n};\n\nasync function writeEnvAmapKeyFile(filePath, data) {\n  // https://nodejs.org/docs/latest-v16.x/api/fs.html#fsexistspath-callback\n  fs.open(filePath, \"wx\", async (err, fd) => {\n    if (err) {\n      if (err.code === \"EEXIST\") {\n        await handleWrite(filePath, data);\n      }\n      process.exit(1);\n      return;\n    }\n\n    try {\n      await handleWrite(filePath, data);\n    } finally {\n      fs.close(fd, (error) => {\n        if (error) {\n          throw error;\n        }\n      });\n      process.exit(1);\n    }\n  });\n}\n\n// 读取文件内容\nasync function handleReadFile(fileName) {\n  try {\n    const promise = fsPromise.readFile(fileName, { encoding: \"utf8\" });\n\n    return await promise;\n  } catch (err) {\n    // When a request is aborted - err is an AbortError\n    console.error(err);\n    return \"\";\n  }\n}\n\n// 检查本地根目录是否存在`.env.local`文件\nasync function handleRevertEnvFile() {\n  try {\n    await fsPromise.stat(envLocalFilePath);\n\n    const envAmapFileContent = await handleReadFile(envLocalFilePath);\n    const envFileContent = await handleReadFile(envFilePath);\n\n    if (envAmapFileContent === \"\") {\n      return;\n    }\n\n    const replaceStr = envFileContent.replace(envAmapFileContent, \"\");\n\n    await writeEnvAmapKeyFile(envFilePath, replaceStr);\n  } catch (error) {\n    console.log(error);\n    console.log(\n      `${chalk.red.bgYellow(\n        \"请检查 `.env.[development|production]` 文件，若有新增加的高德地图 API KEY，请撤回更改，勿提交到远程仓库\"\n      )}`\n    );\n  }\n}\n\nhandleRevertEnvFile();\n```\n\n3. 关于打 release 生产包时获取不到自定义 env 变量\n\n> https://github.com/luggit/react-native-config/issues/640\n\n![](https://mmbiz.qpic.cn/sz_mmbiz_png/Az6S7PrZXXZSPkKoic0VcqUCDcBGZZNcp99I2A291UjydKn9EickZozL1Mh0IvcK1olka4JfUvnhHBrVoxTBhUTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\nandroid/app/proguard-rules.pro 添加下面这行：\n\n```\n-keep class com.mypackage.BuildConfig { *; }\n```\n\n4. 遗留的小问题\n\n本地开发时，执行`npm run android`，npm scripts 钩子执行不了`postandroid`，导致复制到`.env.development`文件里的变量删除不了。`npm run build:android`打包的时候不存在这个问题。\n\n### 5.3 优雅的修改包的版本号\n\n> https://github.com/stovmascript/react-native-version\n\n- 安装\n\n```\nyarn add react-native-version --dev\n```\n\n- package.json 中添加 scripts 脚本\n\n```diff\n{\n  \"name\": \"AwesomeProject\",\n  \"version\": \"0.0.1\",\n  \"scripts\": {\n    \"start\": \"node node_modules/react-native/local-cli/cli.js start\",\n+   \"postversion\": \"react-native-version\"\n  }\n}\n```\n\n- 使用\n\n每次打包发布前，先执行`npm version x.x.x`它会自动把新的版本号更新到 android 和 ios 中，然后再执行打包命令即可\n\n### 5.4 修改包的名称\n\n修改 android/app/src/main/res/values/strings.xml\n\n```xml\n<resources>\n    <string name=\"app_name\">修改成你想要的包名</string>\n</resources>\n```\n\n### 5.5 打包图片报错 mergeReleaseResources FAILED\n\n- 代码中使用图片的地方\n\n```jsx\nimport { ImageBackground, useWindowDimensions } from \"react-native\";\n\n<ImageBackground\n  source={require(\"../../assets/img/mybg.png\")}\n  resizeMode=\"cover\"\n  style={{\n    ...styles.backgroundImg,\n    height: useWindowDimensions().height,\n  }}\n/>;\n```\n\n- 报错如下\n\n```\n* What went wrong:\nExecution failed for task ':app:mergeReleaseResources'.\n> A failure occurred while executing com.android.build.gradle.internal.res.Aapt2CompileRunnable\n   > Android resource compilation failed\n     ERROR:/android/app/build/generated/res/react/release/drawable-mdpi/src_assets_img_bg.png: AAPT: error: file failed to compile.\n```\n\n- 解决：\n\nandroid\\app 下的 build.gradle 文件中添加如下代码\n\n```diff\nandroid {\n    ...\n+    // 解决打包png图片报错\n+    aaptOptions.cruncherEnabled = false\n+    aaptOptions.useNewCruncher = false\n    ...\n}\n```\n\n### 5.6 本地开发 http 请求失败\n\n两种方式，推荐第一种\n\n1. 使用 https 请求\n\n2. 修改配置\n\n- 在 res 下新增加一个 xml 目录，然后创建一个名为 network_security_config.xml 文件，文件内容\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <base-config cleartextTrafficPermitted=\"true\" />\n</network-security-config>\n```\n\n- 在 android/app/src/main/AndroidManifest.xml 文件中添加：\n\n```diff\n<application>\n+ android:networkSecurityConfig=\"@xml/network_security_config\"\n</application>\n```\n\n### 5.7 安卓 Text 组件文字显示不全\n\n设置 fontFamily 为 lucida grande，或者为空\n\n```css\nfontfamily: \"lucida grande\";\n```\n\n### 5.8 android 绝对定位时点击事件失效\n\n> https://segmentfault.com/q/1010000022868789\n\n**解决：** 在最外面在加一个 View，固定高度，点击就可以触发\n\n### 5.9 android 侧滑退出应用问题\n\n```javascript\nimport React, { useEffect, useCallback, memo, Fragment, useRef } from \"react\";\nimport {\n  Platform,\n  BackHandler,\n  Text,\n  StyleSheet,\n  AppState,\n  ToastAndroid,\n} from \"react-native\";\nimport { useNavigate, useLocation } from \"react-router-native\";\nimport { Toast } from \"@ant-design/react-native\";\n\nconst ResetBack = () => {\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const numRef = useRef(1);\n\n  const _handleAppStateChange = function (nextAppState) {\n    // console.log(appState);\n    console.log(\"nextAppState==>\", nextAppState);\n\n    if (nextAppState && nextAppState === \"background\" && numRef.current > 0) {\n      console.log(\"numRef.current==>\", numRef.current);\n      if (Platform.OS === \"android\") {\n        ToastAndroid.showWithGravity(\n          \"已切到后台\",\n          ToastAndroid.SHORT,\n          ToastAndroid.BOTTOM\n        );\n      }\n    }\n  };\n\n  const handleHardwareBackPress = useCallback(() => {\n    if (location.pathname === \"/\") {\n      numRef.current--;\n\n      if (numRef.current === 0) {\n        Toast.info({\n          content: <Text style={styles.txt}>在滑一次退出</Text>,\n        });\n\n        BackHandler.removeEventListener(\n          \"hardwareBackPress\",\n          handleHardwareBackPress\n        );\n\n        return true;\n      }\n    }\n\n    navigate(-1);\n    return true;\n  }, [navigate, location]);\n\n  useEffect(() => {\n    // AppState.addEventListener('change', _handleAppStateChange);\n    // https://github.com/facebook/react-native/issues/34644#issuecomment-1245026317\n    const listener = AppState.addEventListener(\"change\", _handleAppStateChange);\n\n    return () => {\n      // AppState.removeEventListener('change', _handleAppStateChange);\n      listener.remove();\n    };\n  }, []);\n\n  useEffect(() => {\n    // 禁用 Android 上的返回按钮(侧滑返回)\n    if (Platform.OS === \"android\") {\n      BackHandler.addEventListener(\n        \"hardwareBackPress\",\n        handleHardwareBackPress\n      );\n    }\n\n    return () => {\n      if (Platform.OS === \"android\") {\n        BackHandler.removeEventListener(\n          \"hardwareBackPress\",\n          handleHardwareBackPress\n        );\n\n        numRef.current = 1;\n      }\n    };\n  }, [handleHardwareBackPress]);\n\n  return <Fragment />;\n};\n\nconst styles = StyleSheet.create({\n  txt: {\n    fontFamily: \"\",\n    color: \"#ffffff\",\n  },\n});\n\nexport default memo(ResetBack);\n```\n\n### 5.10 自定义双击事件 Button 组件\n\n> chatgpt 给我的答案\n\n在 rn 0.71 及更高版本中，可以使用 TouchableWithoutFeedback 组件来捕获双击事件。\n\nTouchableWithoutFeedback 提供了 onPress 和 onLongPress 回调函数以及 delayPressIn 和 delayPressOut 属性，这些属性可以用于检测双击事件\n\n您可以根据需要调整 delayPressIn 和 delayPressOut 属性的值。例如，如果您希望用户必须在 500 毫秒内双击按钮，则可以将 DOUBLE_PRESS_DELAY 常量设置为 500。\n\n```javascript\nimport React, { useRef } from \"react\";\nimport { TouchableWithoutFeedback, Text } from \"react-native\";\n\nconst MyDoubleClickButton = (props) => {\n  // doubleClickTime为双击完成的时间\n  const { onPress, title, doubleClickTime, textStyle } = props;\n  const lastPress = useRef(0);\n\n  const handlePress = () => {\n    const now = new Date().getTime();\n    const DOUBLE_PRESS_DELAY = doubleClickTime;\n    if (now - lastPress.current < DOUBLE_PRESS_DELAY) {\n      onPress();\n    }\n    lastPress.current = now;\n  };\n\n  return (\n    <TouchableWithoutFeedback\n      onPress={handlePress}\n      delayPressIn={doubleClickTime / 2}\n      delayPressOut={doubleClickTime / 2}\n    >\n      <Text style={textStyle}>{title}</Text>\n    </TouchableWithoutFeedback>\n  );\n};\n\nexport default MyDoubleClickButton;\n```\n\n### 5.11 设置剪切板\n\n> https://github.com/react-native-clipboard/clipboard\n\n```javascript\nimport Clipboard from \"@react-native-clipboard/clipboard\";\n\n// 设置值：\nClipboard.setString(\"hello world\");\n// 取值：\nconst fetchCopiedText = async () => {\n  const text = await Clipboard.getString();\n  setCopiedText(text);\n};\n```\n\n### 5.12 关于使用`react-native-webview`\n\n> https://github.com/react-native-webview/react-native-webview/blob/HEAD/docs/Reference.md\n\n1. 安装\n\n```\nyarn add  react-native-webview\n```\n\n**注意：** 一定要在安装完 react-native-webview 之后，然后重新启动，才会生效，不然会报错\n（重启后，会重新下载依赖，这个过程，视网络情况而定，可能有点慢）\n\n```\nTypeError: Cannot read property 'isFileUploadSupported' of null, js engine: hermes\n```\n\n2. 网页 js 和原生进行通信\n\n如下示例，给网页插入一段脚本，获取网页上的图片点击事件，并且拿到图片的 src 链接\n\n```javascript\nimport React, { Component } from \"react\";\nimport { View } from \"react-native\";\nimport { WebView } from \"react-native-webview\";\n\nconst INJECTED_JAVASCRIPT = `\n  var imgList = document.querySelectorAll(\"img\");\n\n  Array.from(imgList).forEach(el => {\n    el.addEventListener(\"click\", function () {\n      window.ReactNativeWebView.postMessage(JSON.stringify({type: 'previewimg', data: this.src}));\n    });\n  });\n  \n  // 注意：这行是必须添加的，否则添加失败\n  true; // note: this is required, or you'll sometimes get silent failures\n`;\n\nconst MyWebView = () => {\n  return (\n    <WebView\n      source={{ uri: `http://xxx/posts/detail/123` }}\n      injectedJavaScript={INJECTED_JAVASCRIPT}\n      onMessage={(event) => {\n        alert(event.nativeEvent.data);\n      }}\n    />\n  );\n};\n```\n\n3. IOS 报错 RNCWebView 未找到 UIManager\n\n报错如下：\n\n```\nInvariant Violation: requireNativeComponent: \"RNCWebView\" was not found in the UIManager\n```\n\n**解决：**\n\n```\ncd ios\n\npod install\n```\n\n然后重启项目即可\n\n4. WebView 页面不显示\n\n关键原因是，WebView 的父组件没有设置高度，导致 WebView 页面不显示\n\n**解决：** 给 WebView 父组件设置一个高度即可\n\n### 5.13 关于使用高德地图\n\n> https://github.com/qiuxiang/react-native-amap3d\n\n**定位模块**：`@react-native-community/geolocation`获取的坐标是 gps 坐标，高德地图使用时要转换， `react-native-amap-geolocation`可以直接获取到位置信息，无需再进行转换\n\n1. 安装\n\n```\nyarn add react-native-amap3d\n```\n\n2. `android/app/src/main/AndroidManifest.xml`添加权限\n\n```xml\n<!-- 精确定位 -->\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n<!-- 模糊定位 -->\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n```\n\n3. 使用\n\n```javascript\nimport { AMapSdk, MapView, MapType } from \"react-native-amap3d\";\nimport { Platform, PermissionsAndroid } from \"react-native\";\n\n// 申请定位权限\nconst handleAndroidPermissin = useCallback(async () => {\n  try {\n    const granted = await PermissionsAndroid.requestMultiple(\n      [\n        PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,\n        PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION,\n      ],\n      {\n        title: \"位置信息授权\",\n        message: \"获取当前位置信息测试\",\n        buttonNeutral: \"跳过\",\n        buttonNegative: \"取消\",\n        buttonPositive: \"同意\",\n      }\n    );\n\n    console.log(\"granted==>\", granted);\n\n    if (\n      granted[\"android.permission.ACCESS_FINE_LOCATION\"] ===\n      PermissionsAndroid.RESULTS.GRANTED\n    ) {\n      console.log(\"可以定位了\");\n    } else if (\n      granted[\"android.permission.ACCESS_FINE_LOCATION\"] ===\n      PermissionsAndroid.RESULTS.DENIED\n    ) {\n      Toast.fail({\n        content: \"已拒绝获取位置信息\",\n      });\n    } else {\n      Toast.fail({\n        content: \"用户已拒绝，且不愿被再次询问\",\n      });\n    }\n  } catch (error) {\n    console.warn(error);\n  }\n}, []);\n\nuseEffect(() => {\n  AMapSdk.init(\n    Platform.select({\n      android: Config.AMP_ANDROID_API_KEY,\n    })\n  );\n}, []);\n\nreturn <MapView mapType={MapType.Satellite} />;\n```\n\n4. 关于 GPS 坐标转高德坐标\n\n> https://www.jianshu.com/p/dd0c017250e4\n\n推荐使用[高德坐标转换](https://lbs.amap.com/api/webservice/guide/api/convert)\n\n5. 高德地图逆地理编码服务\n\n> https://lbs.amap.com/api/javascript-api-v2/guide/services/geocoder#t2\n\n```javascript\nAMap.plugin(\"AMap.Geocoder\", function () {\n  var geocoder = new AMap.Geocoder({\n    city: \"010\", // city 指定进行编码查询的城市，支持传入城市名、adcode 和 citycode\n  });\n\n  var lnglat = [111, 30];\n\n  geocoder.getAddress(lnglat, function (status, result) {\n    if (status === \"complete\" && result.info === \"OK\") {\n      // result为对应的地理位置详细信息\n    }\n  });\n});\n```\n\n6. 安卓从地图页返回上一页 app 闪退\n\n> https://github.com/qiuxiang/react-native-amap3d/issues/742\n\n**解决**：`android/app/src/main/AndroidManifest.xml文件application`添加`android:allowNativeHeapPointerTagging=\"false\"`\n\n7. 打正式 release 包闪退\n\n> https://github.com/qiuxiang/react-native-amap3d/issues/762\n\n**解决**：在 `android/appproguard-rules.pro` 文件添加下面代码，重新打包\n\n```\n# 高德地图release包闪退问题\n# 3D 地图 V5.0.0之前：\n-keep   class com.amap.api.maps.**{*;}\n-keep   class com.autonavi.amap.mapcore.*{*;}\n-keep   class com.amap.api.trace.**{*;}\n\n# 3D 地图 V5.0.0之后：\n-keep   class com.amap.api.maps.**{*;}\n-keep   class com.autonavi.**{*;}\n-keep   class com.amap.api.trace.**{*;}\n\n# 定位\n-keep class com.amap.api.location.**{*;}\n-keep class com.amap.api.fence.**{*;}\n-keep class com.autonavi.aps.amapapi.model.**{*;}\n\n# 搜索\n-keep   class com.amap.api.services.**{*;}\n\n# 2D地图\n-keep class com.amap.api.maps2d.**{*;}\n-keep class com.amap.api.mapcore2d.**{*;}\n\n# 导航\n-keep class com.amap.api.navi.**{*;}\n-keep class com.autonavi.**{*;}\n```\n\n## 6. 自定义安卓原生模块供 js 端使用\n\n> https://www.reactnative.cn/docs/native-modules-android\n\n基本步骤是：\n\n1. 创建模块：在`android/app/src/main/java/com/your-app-name`下新建一个 java 文件，如`ToastModule.java`\n\n2. 注册模块：在`android/app/src/main/java/com/your-app-name`下新建一个 java 文件，如`CustomToastPackage.java`\n\n3. 在`android/app/src/main/java/com/your-app-name/MainApplication.java`中引入自己的包\n\n4. js 端通过暴露出来的模块名调用原生方法\n\n### 6.1 调用自定义原生安卓模块-手电筒\n\n> 自定义封装一个手电筒模块，供 js 端调用，可以打开/关闭手机的手电筒\n\n1. `android/app/src/main/AndroidManifest.xml`加入如下权限\n\n```xml\n<!-- 摄像头,手电筒 -->\n<uses-permission android:name=\"android.permission.CAMERA\" />\n<uses-permission android:name=\"android.permission.FLASHLIGHT\" />\n<uses-feature android:name=\"android.hardware.camera\" />\n```\n\n2. `android/app/src/main/java/com/your-app-name` 下新建 `FlashlightManModule.java` 文件\n\n```java\npackage com.your-app-name;\n\nimport android.hardware.Camera;\nimport android.hardware.camera2.CameraAccessException;\nimport android.hardware.camera2.CameraManager;\nimport android.hardware.camera2.CameraCharacteristics;\nimport android.os.Build;\nimport android.content.pm.PackageManager;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\n\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class FlashlightManModule extends ReactContextBaseJavaModule {\n  private static ReactApplicationContext reactContext;\n  private Camera camera;\n  private Camera.Parameters mParameters;\n\n  private CameraManager mCameraManager;\n  private boolean hasClosed = true; // 定义开关状态，状态为false，打开状态，状态为true，关闭状态;\n\n  private static final int FLASH_LIGHT_ON = 1; // 打开手电筒\n  private static final int FLASH_LIGHT_OFF = 0; // 关闭手电筒\n  private static final String E_LAYOUT_ERROR = \"E_LAYOUT_ERROR\";\n  private static final String HAS_FLASH = \"HAS_FLASH\";\n  private static final String NOT_HAS_FLASH = \"NOT_HAS_FLASH\";\n\n  public FlashlightManModule(ReactApplicationContext context) {\n    super(context);\n    reactContext = context;\n  }\n\n  @Override\n  public String getName() {\n    return \"FlashlightManager\";\n  }\n\n  // 是否支持闪光灯\n  @ReactMethod\n  public void isSuportFlashlight(Promise promise) {\n    try {\n      PackageManager packageManager = reactContext.getPackageManager();\n      //检查设备是否支持闪光灯\n      boolean hasFlash = packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_FLASH);\n\n      String hasFlashStr = hasFlash ? HAS_FLASH : NOT_HAS_FLASH;\n\n      if(!hasFlash) {\n        promise.reject(E_LAYOUT_ERROR, hasFlashStr);\n        return;\n      }\n\n      CameraManager mCameraManager = (CameraManager) reactContext.getSystemService(ReactContext.CAMERA_SERVICE);\n      String[] cameraIds = mCameraManager.getCameraIdList();\n      String cameraId = cameraIds[0];\n      boolean r = mCameraManager.getCameraCharacteristics(cameraId).get(CameraCharacteristics.FLASH_INFO_AVAILABLE);\n      promise.resolve(r);\n    } catch(CameraAccessException e) {\n      e.printStackTrace();\n      promise.reject(E_LAYOUT_ERROR, e);\n    }\n  }\n\n  // 闪光灯开、关\n  @ReactMethod\n  public void toggleLight(int lightType, Promise promise) {\n    try {\n      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n        // Android7.x之后：\n        //获取CameraManager\n        CameraManager mCameraManager = (CameraManager) reactContext.getSystemService(ReactContext.CAMERA_SERVICE);\n        String[] cameraIds = mCameraManager.getCameraIdList();\n        String cameraId = cameraIds[0];\n        hasClosed = lightType == FLASH_LIGHT_ON;\n        mCameraManager.setTorchMode(cameraId, lightType == FLASH_LIGHT_ON);\n      } else {\n        // Android7.x之前代码\n        if(lightType == FLASH_LIGHT_ON) {\n          camera = Camera.open();\n          mParameters = camera.getParameters();\n          mParameters.setFlashMode(mParameters.FLASH_MODE_TORCH);// 开启\n          camera.setParameters(mParameters);\n          hasClosed = false;\n        } else {\n          mParameters.setFlashMode(mParameters.FLASH_MODE_OFF);// 关闭\n          camera.setParameters(mParameters);\n          camera.release();\n          hasClosed = true;\n        }\n      }\n\n\n      promise.resolve(lightType);\n    } catch (CameraAccessException e) {\n      promise.reject(E_LAYOUT_ERROR, e);\n    }\n  }\n}\n```\n\n3. `android/app/src/main/java/com/your-app-name` 下新建 `FlashlightManModulePackage.java` 文件\n\n```java\npackage com.your-app-name;\n\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.uimanager.ViewManager;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class FlashlightManModulePackage implements ReactPackage {\n\n  @Override\n  public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {\n    return Collections.emptyList();\n  }\n\n  @Override\n  public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {\n    List<NativeModule> modules = new ArrayList<>();\n\n    modules.add(new FlashlightManModule(reactContext));\n\n    return modules;\n  }\n\n}\n```\n\n4. `android/app/src/main/java/com/your-app-name/MainApplication.java`\n\n```java\n...\nimport com.your-app-name.FlashlightManModulePackage; // <-- 引入你自己的包\n...\nprotected List<ReactPackage> getPackages() {\n  @SuppressWarnings(\"UnnecessaryLocalVariable\")\n  List<ReactPackage> packages = new PackageList(this).getPackages();\n  // Packages that cannot be autolinked yet can be added manually here, for example:\n  // packages.add(new MyReactNativePackage());\n  packages.add(new FlashlightManModulePackage()); // <-- 添加这一行，类名替换成你的Package类的名字 name.\n  return packages;\n}\n```\n\n5. js 端调用上面写的原生模块方法\n\n```javascript\nimport {NativeModules, PermissionsAndroid} from 'react-native';\n\n// public String getName()中返回的字符串\nlet FlashlightManager = NativeModules.FlashlightManager;\nconst lightTypeRef = useRef(false);\n\n// 申请摄像机权限\nconst handleAndroidPermissin = async () => {\n  try {\n    const granted = await PermissionsAndroid.request(\n      PermissionsAndroid.PERMISSIONS.CAMERA,\n      {\n        title: '闪光灯授权',\n        message: '获取闪光灯权限',\n        buttonNeutral: '跳过',\n        buttonNegative: '取消',\n        buttonPositive: '同意',\n      },\n    );\n\n    console.log('授权结果granted==>', granted);\n    if (granted === PermissionsAndroid.RESULTS.GRANTED) {\n      console.log('可以打开闪光灯了');\n      return Promise.resolve();\n    } else if (granted === PermissionsAndroid.RESULTS.DENIED) {\n      Toast.fail({\n        content: '已拒绝打开闪光灯',\n      });\n      return Promise.reject();\n    } else {\n      Toast.fail({\n        content: '用户已拒绝，且不愿被再次询问',\n      });\n      return Promise.reject();\n    }\n  } catch (error) {\n    console.error(error);\n  }\n};\n\n// 打开、关闭手电筒\nconst toggleLight = async () => {\n  try {\n    await handleAndroidPermissin();\n    const   = await FlashlightManager.isSuportFlashlight();\n    console.log('当前手机是否支持闪光灯:', suportRes);\n    console.log('准备打开/关闭手电筒:', lightTypeRef.current ? 0 : 1);\n    const res = await FlashlightManager.toggleLight(\n      lightTypeRef.current ? 0 : 1,\n    );\n\n    lightTypeRef.current = res;\n    console.log('手电筒打开/关闭结果:', res);\n  } catch (error) {\n    console.error('打开/关闭手电筒异常', error);\n  }\n};\n```\n\n### 6.2 调用自定义原生安卓模块-Notification 通知\n\n> 点击某按钮(线上应该是收到服务端消息)，手机上出现 app 的通知(自定义通知标题和通知内容，并且携带路径参数)，用户点击通知打开 app，接收路径参数，跳转指定页面\n\n1. `android/app/src/main/java/com/your-app-name` 新建 `MyNotificationModule.java`文件\n\n```java\npackage com.your-app-name;\n\nimport android.os.Build;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.content.Intent;\nimport android.app.PendingIntent;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class MyNotificationModule extends ReactContextBaseJavaModule {\n  private static ReactApplicationContext reactContext;\n  private static final String CHANNEL_ID = \"notification_channel\";\n  private static final String CHANNEL_NAME = \"notification_channel_name\";\n\n  private Class getActivityClass(String activityName) {\n    try {\n      if (activityName.equals(\"PageToJumpTo\")) {\n        return Class.forName(\"com.your-app-name.MainActivity\");\n      }\n    } catch (ClassNotFoundException e) {\n      e.printStackTrace();\n    }\n    return null;\n  }\n\n  public MyNotificationModule(ReactApplicationContext context) {\n    super(context);\n    reactContext = context;\n  }\n\n  @Override\n  public String getName() {\n    return \"MyNotificationManager\";\n  }\n\n  @ReactMethod\n  public void show(int contextId, String title, String content, String activityName, String routePath) {\n    // https://juejin.cn/post/7195496297151381565\n    // https://blog.csdn.net/canghieever/article/details/125430116\n\n    // 创建一个NotificationManager对通知进行管理\n    NotificationManager mNotificationManager = (NotificationManager) reactContext.getSystemService(ReactContext.NOTIFICATION_SERVICE);\n    Notification notification = null;\n\n    Intent intent = new Intent(reactContext, getActivityClass(activityName));\n    // Intent intent = new Intent(reactContext, PageToJumpToActivity.class);\n    // intent可以携带参数到指定页面\n    intent.putExtra(\"pageToJumpKey\", routePath);\n\n    // https://blog.csdn.net/yubo_725/article/details/124413000\n    // Targeting S+ (version 31 and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE be specified\n    PendingIntent pendingIntent;\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\n      // https://blog.csdn.net/zhangxiweicaochen/article/details/14002469\n      // PendingIntent.getActivity(context,id, intent,PendingIntent.FLAG_UPDATE_CURRENT);\n      // 上面id，一定要唯一，不然Intent就是接受到的重复！\n      pendingIntent = PendingIntent.getActivity(reactContext, contextId, intent, PendingIntent.FLAG_IMMUTABLE);\n    } else {\n      pendingIntent = PendingIntent.getActivity(reactContext, contextId, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n    }\n\n    if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n      // 安卓8.0之后\n      // 创建channel\n      // 参数：channel ID(ID可以随便定义，但保证全局唯一性)，channel 名称，重要等级\n      NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH);\n      mNotificationManager.createNotificationChannel(channel);\n\n      notification = new Notification.Builder(reactContext, CHANNEL_ID)\n                .setContentTitle(title)\n                .setContentText(content)\n                .setSmallIcon(R.mipmap.ic_launcher)\n                .setAutoCancel(true) // 当点击通知后显示栏的通知不再显示\n                .setContentIntent(pendingIntent) // 点击跳到通知详情\n                .build();\n    } else {\n      notification = new Notification.Builder(reactContext)\n                .setContentTitle(title)\n                .setContentText(content)\n                .setSmallIcon(R.mipmap.ic_launcher)\n                .setAutoCancel(true)\n                .setContentIntent(pendingIntent)\n                .build();\n    }\n\n    // notify(int id,Notification notification)\n    // 第一个参数id可以随便填，第二个参数就是我们要发送的通知\n    mNotificationManager.notify(100, notification);\n  }\n}\n```\n\n2. `android/app/src/main/java/com/your-app-name` 新建 `MyNotificationModulePackage.java`文件\n\n```java\npackage com.your-app-name;\n\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.uimanager.ViewManager;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MyNotificationModulePackage implements ReactPackage {\n\n  @Override\n  public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {\n    return Collections.emptyList();\n  }\n\n  @Override\n  public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {\n    List<NativeModule> modules = new ArrayList<>();\n\n    modules.add(new MyNotificationModule(reactContext));\n\n    return modules;\n  }\n}\n```\n\n3. `android/app/src/main/java/com/your-app-name/MainApplication.java`文件中引入自己的模块\n\n```diff\n+ import com.your-app-name.MyNotificationModulePackage;\n\npublic class MainApplication extends Application implements ReactApplication {\n    ...\n    @Override\n    protected List<ReactPackage> getPackages() {\n      @SuppressWarnings(\"UnnecessaryLocalVariable\")\n      List<ReactPackage> packages = new PackageList(this).getPackages();\n\n+     packages.add(new MyNotificationModulePackage());// <-- 添加这一行，类名替换成你的Package类的名字 name.\n      return packages;\n    }\n    ...\n}\n```\n\n4. `android/app/src/main/java/com/your-app-name/MainActivity.java` 添加代码监听 onNewIntent 事件，获取 `MyNotificationModulePackage`文件`intent.putExtra`的参数\n\n```java\n+ import android.content.Intent;\n+ import com.facebook.react.bridge.WritableMap;\n+ import com.facebook.react.bridge.Arguments;\n+ import com.facebook.react.modules.core.DeviceEventManagerModule;\n+ import com.facebook.react.bridge.ReactApplicationContext;\n// import com.facebook.react.bridge.ReactContext;\n+ import com.facebook.react.ReactInstanceManager;\n\npublic class MainActivity extends ReactActivity {\n    ...\n+    @Override\n+    public void onNewIntent(Intent intent) {\n+       // 监听onNewIntent事件\n+       super.onNewIntent(intent);\n+       String data = intent.getStringExtra(\"pageToJumpKey\");\n\n+        if(data != null) {\n+          WritableMap params = Arguments.createMap();\n+          params.putString(\"pageToJumpKey\", data);\n\n+          ReactInstanceManager mReactInstanceManager = getReactNativeHost().getReactInstanceManager();\n+          ReactApplicationContext context= (ReactApplicationContext) mReactInstanceManager.getCurrentReactContext();\n\n+          context\n+                  .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n+                  .emit(\"pageToJumpKey\", params);\n+        }\n+    }\n}\n```\n\n5. js 端调用 MyNotificationModule 模块\n\n```javascript\nimport { NativeModules } from \"react-native\";\n\nlet MyNotificationManager = NativeModules.MyNotificationManager;\n\nconst handleNotification = async () => {\n  try {\n    await handleNotificationPermission();\n\n    const ctxId = Math.ceil(Math.random() * 10000000);\n    MyNotificationManager.show(\n      ctxId, // android中PendingIntent.getActivity的id,每次调用必须唯一，否则可能拿到旧数据\n      \"文章更新啦！\", // 通知标题\n      \"查看新文章\", // 通知内容\n      \"PageToJumpTo\", // 需要调用android中哪个activity名称\n      \"/list\" // 点击通知时需要跳转的路径\n    );\n  } catch (error) {\n    console.log(error);\n  }\n};\n```\n\n6. js 端监听点击通知传递进来的参数\n\n```javascript\nimport React, { memo, useEffect, Fragment } from \"react\";\nimport { NativeEventEmitter, NativeModules } from \"react-native\";\nimport { useNavigate } from \"react-router-native\";\n\nconst PageJumpTo = () => {\n  const navigate = useNavigate();\n\n  useEffect(() => {\n    const eventEmitter = new NativeEventEmitter(\n      NativeModules.MyNotificationModule\n    );\n\n    const eventListener = eventEmitter.addListener(\"pageToJumpKey\", (data) => {\n      // data就是MainActivity传过来的params参数\n      console.log(\"pageToJumpKey==>\", data);\n      navigate(data.pageToJumpKey);\n    });\n\n    return () => {\n      eventListener && eventListener.remove(); // 组件卸载时记得移除监听事件\n    };\n  }, [navigate]);\n\n  return <Fragment />;\n};\n\nexport default memo(PageJumpTo);\n```\n\n## 7. 调试\n\n1. Chrome 浏览器 的 DevTools 来调试 Hermes 上的 JS\n\n[文档](https://www.reactnative.cn/docs/hermes#%E4%BD%BF%E7%94%A8-google-chrome-%E7%9A%84-devtools-%E6%9D%A5%E8%B0%83%E8%AF%95-hermes-%E4%B8%8A%E7%9A%84-js)\n\n2. react-devtools 调试\n\n```\nyarn global add react-devtools\n```\n\n```\nnpx react-devtools\n```\n\n如果用的是本地手机，还需要执行\n\n```\nadb reverse tcp:8097 tcp:8097\n```\n\n## 8. 打包发布\n\n跟着[文档](https://www.reactnative.cn/docs/signed-apk-android)来即可\n\n## 9. 总结\n\n练习时长 2 月半，远远不够，app 很粗糙，距离上架还有一段距离，况且代码里现在只兼顾到了 android，忽略了 ios。\n"},{"id":"uIKJuw7l4gnuXCy2IPNXK","title":"仿抖音左右歪头图片选择","keywords":["face-api"," 人脸识别"," 抖音"],"date":"2022-11-29","fileName":"face-api","content":"\n- [在线体验](https://srect.github.io/face-api.js)\n\n- [项目 github 仓库](https://github.com/sRect/face-api.js/tree/dy)\n\n> 前一阵子在刷抖音时，看到一个通过左右歪头选择两侧图片的视频，感觉很有趣。顿时想到了 n 年前的[**face-api.js**](https://github.com/justadudewhohacks/face-api.js)，那就基于这个来做吧。总体做好后，有很多细节需要改进，不够细腻丝滑。\n\n### 1. 需求分析\n\n直接开搞吧！\n\n1. 页面基本布局，左右两侧图片，而且有缩放和移动动画\n2. 需要打开摄像头，获取视频流，通过 video 展现出来\n3. 需要检测人脸是向哪一侧歪头\n\n### 2. 具体实现\n\n#### 2.1 页面布局和 animation 动画\n\n这个不难，布局好后，就是添加 css 动画，我这里写的很粗糙，不细腻，但勉强能用，例如下面 _leftHeartMove_ 为中间的小爱心向左侧移动动画\n\n```css\n.heart {\n  width: 30px;\n  height: 30px;\n  padding: 4px;\n  box-sizing: border-box;\n  border-radius: 50%;\n  background-color: #fff;\n  position: absolute;\n  top: -15px;\n  left: 50%;\n  transform: translateX(-50%) rotateZ(0deg) scale(1);\n  animation: leftHeartMove 0.5s linear;\n  animation-fill-mode: forwards;\n  z-index: 2;\n}\n\n@keyframes leftHeartMove {\n  from {\n    top: -15px;\n    left: 50%;\n    transform: translateX(-50%) rotateZ(0deg) scale(1);\n  }\n\n  to {\n    top: 65px;\n    left: -13%;\n    transform: translateX(-50%) rotateZ(-15deg) scale(1.2);\n  }\n}\n```\n\n#### 2.2 打开摄像头并显示\n\n**注意点**\n\n1. 关于 h5`navigator.mediaDevices.getUserMedia` 这个 api，本地开发`localhost`是可以拉起摄像头打开提示的，线上部署必须是`https`节点才行，`http`不能唤起打开摄像头\n\n![](../img/face-api/WX20221128-221028@2x.png)\n\n2. 关于获取到视频流后，`video`视频播放，需要镜面翻转，这个可以通过 css 的`transform: rotateY(180deg)`来翻转\n\n3. 关于`video`播放不能在手机上竖屏全屏，可以给 video 设置 css`object-fit:cover`来充满屏幕\n\n```html\n<video id=\"video\" class=\"video\" playsinline autoplay muted></video>\n```\n\n```css\n.video {\n  width: 100%;\n  height: 100%;\n  transform: rotateY(180deg);\n  object-fit: cover;\n}\n```\n\n- 获取摄像头视频流\n\n```javascript\nasync getUserMedia() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    try {\n      // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#examples\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: false,\n        video: true,\n        video: {\n          facingMode: \"user\", // 前置摄像头\n          // facingMode: { exact: \"environment\" }，// 后置摄像头\n          width: { min: 1280, max: 1920 },\n          height: { min: 720, max: 1080 },\n        },\n      });\n\n      return Promise.resolve(stream);\n    } catch (error) {\n      return Promise.reject();\n    }\n  }\n\n  const errorMessage =\n    \"This browser does not support video capture, or this device does not have a camera\";\n  alert(errorMessage);\n}\n```\n\n- video 播放视频流\n\n```javascript\nasync openCamera(e) {\n  try {\n    const stream = await this.getUserMedia();\n    this.video.srcObject = stream;\n    this.video.onloadedmetadata = async () => {\n      this.video.play();\n    };\n  } catch (error) {\n    console.log(error);\n    alert(\"打开摄像头失败\");\n  }\n}\n```\n\n- 关闭视频\n\n```javascript\nasync closeCamera() {\n  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/stop\n  const tracks = this.video.srcObject.getTracks();\n\n  tracks.forEach((track) => {\n    track.stop();\n  });\n\n  this.video.srcObject.srcObject = null;\n}\n```\n\n#### 2.3 检测人脸左右倾斜\n\n![](../img/face-api/landmarks.png)\n\n通过`face-api.js`拿到人脸`landmarks`特征数据后，可以直接拿到左右眼的数据，分别通过求 Y 轴方向的平均值，然后比较这个平均值，便可以简单得出人脸向左还是向右倾斜，简单吧，角度都不用求了！\n\n```html\n<div style=\"position: relative;width: 100%;height: 100%;\">\n  <video\n    id=\"video\"\n    class=\"video\"\n    playsinline\n    autoplay\n    muted\n    style=\"object-fit:cover\"\n  ></video>\n  <canvas id=\"overlay\" class=\"overlay\"></canvas>\n</div>\n```\n\n```css\n.video {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 0;\n  transform: rotateY(180deg);\n}\n\n.overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n```\n\n- 加载模型\n\n```javascript\nimport * as faceapi from \"face-api.js\";\n\nasync loadWeight() {\n  // 加载模型\n  await faceapi.nets.ssdMobilenetv1.load(\n    \"./static/weights/ssd_mobilenetv1_model-weights_manifest.json\"\n  );\n  // 加载人脸68特征模型数据\n  await faceapi.nets.faceLandmark68Net.load(\n    \"./static/weights/face_landmark_68_model-weights_manifest.json\"\n  );\n  // await faceapi.nets.faceExpressionNet.load(\n  //   \"/static/weights/face_expression_model-weights_manifest.json\"\n  // );\n  // await faceapi.nets.faceRecognitionNet.load(\n  //   \"./static/weights/face_recognition_model-weights_manifest.json\"\n  // );\n  await faceapi.nets.ageGenderNet.load(\n    \"./static/weights/age_gender_model-weights_manifest.json\"\n  );\n\n  console.log(\"模型加载完成\");\n}\n```\n\n- 计算人脸左右倾斜\n\n```javascript\nhandleFaceLeftOrRight(landmarks) {\n  const DIFF_NUM = 15; // 偏差\n  let leftEye = landmarks.getLeftEye(); // 左眼数据\n  let rightEye = landmarks.getRightEye(); // 右眼数据\n  // let nose = landmarks.getNose();\n\n  let leftEyeSumPoint = leftEye.reduce((prev, cur) => ({\n    x: prev.x + cur.x,\n    y: prev.y + cur.y,\n  }));\n\n  let rightEyeSumPoint = rightEye.reduce((prev, cur) => ({\n    x: prev.x + cur.x,\n    y: prev.y + cur.y,\n  }));\n\n  // let noseSumPoint = nose.reduce((prev, cur) => ({\n  //   x: prev.x + cur.x,\n  //   y: prev.y + cur.y,\n  // }));\n\n  let leftEyeAvgPoint = {\n    x: leftEyeSumPoint.x / leftEye.length,\n    y: leftEyeSumPoint.y / leftEye.length,\n  };\n\n  let rightEyeAvgPoint = {\n    x: rightEyeSumPoint.x / leftEye.length,\n    y: rightEyeSumPoint.y / leftEye.length,\n  };\n\n  // let noseAvgPoint = {\n  //   x: noseSumPoint.x / leftEye.length,\n  //   y: noseSumPoint.y / leftEye.length,\n  // };\n\n  // console.log(leftEyeAvgPoint, rightEyeAvgPoint, noseAvgPoint);\n  let diff = Math.abs(leftEyeAvgPoint.y - rightEyeAvgPoint.y);\n\n  return diff > DIFF_NUM\n    ? leftEyeAvgPoint.y > rightEyeAvgPoint.y\n      ? \"left\"\n      : \"right\"\n    : \"center\";\n}\n```\n\n- 分析 video 视频流\n\n```javascript\nasync handleVideoFaceTracking(cb) {\n    if (this.closed) {\n      window.cancelAnimationFrame(this.raf);\n      return;\n    }\n\n    const options = new faceapi.SsdMobilenetv1Options();\n\n    let task = faceapi.detectAllFaces(this.video, options);\n    task = task.withFaceLandmarks().withAgeAndGender();\n    const results = await task;\n\n    // overlay为canvas元素\n    // video即为video元素\n    const dims = faceapi.matchDimensions(this.overlay, this.video, true);\n    const resizedResults = faceapi.resizeResults(results, dims);\n\n    // console.log(\"options==>\", options);\n    // console.log(\"resizedResults==>\", resizedResults);\n    cb && cb(resizedResults);\n\n    this.raf = requestAnimationFrame(() => this.handleVideoFaceTracking(cb));\n  }\n```\n\n### 3. 参考资料\n\n1. [face-api.js](https://github.com/justadudewhohacks/face-api.js)\n\n2. [getUserMedia MDN](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#examples)\n"},{"id":"SDf-PWeCYOtEtRBHjwVd3","title":"uniapp 打包 h5 问题总结","keywords":["uniapp"," webpack4.x"],"date":"2022-08-08 22:15:07","fileName":"uniapp","content":"\n[本文掘金链接](https://juejin.cn/post/7129492032241795080/)\n\n# uniapp 打包 h5 问题总结\n\n![ ](../img/uniapp/banner.jpeg)\n\n本文对应操作系统及 hbuilderx 版本等\n\n| -         | -               |\n| --------- | --------------- |\n| 操作系统  | macOS           |\n| HbuilderX | 3.4.18.20220630 |\n| Vue       | 2.x             |\n| uView     | 1.x             |\n\n---\n\n## 1. 项目背景\n\n这是一个嵌套在 flutter 里的 h5 项目，外面壳子是 app，里面大部分的页面是 h5，app 直接用 webview 显示 h5 页面\n\n## 2. 开发 h5 为什么要用 uniapp?\n\n因为还要开发微信小程序，使用 uniapp，可以跨平台，节省时间\n\n## 3. 项目初始化\n\n项目初始化是使用[HBuilderX 可视化界面](https://uniapp.dcloud.net.cn/quickstart-hx.html)创建的项目，没有使用[vue-cli 命令行](https://uniapp.dcloud.net.cn/quickstart-cli.html)的方式。\n\n通过官方 IDE 的方式创建的项目，这给后面项目 CI/CD 构建部署，就带来了麻烦。因为不是命令行创建的项目，没法在 linux 里执行命令，只有在本地打包完，然后上传打包完的`unpackage`目录进行部署。当然使用 HBuilderX 也有很多方便的地方。\n\n### 3.1 uni-app HBuilderX 工程与 vue-cli 工程相互转换\n\n[HBuilderX 工程转换为 vue-cli 工程](https://ask.dcloud.net.cn/article/35750)，看到评论区有坑，而且项目一大，遇到坑不一定能解决掉，这样代价就大了。\n\n### 3.2 通过 HBuilderX 方式创建的项目，可以调用 hbuilderx 的打包命令吗？\n\n也就是通过命令行调用 hbuilderx 的打包功能\n\n- [CLI 发行 uni-app 到 H5](https://hx.dcloud.net.cn/cli/publish-h5)\n- [cli 配置环境变量](https://hx.dcloud.net.cn/cli/env)\n\n但是这样还是没有一开始通过 vue-cli 命令行的方式方便，而且都是在本地 windows 或者 mac 上打包，没法在 linux 上通过 shell 脚本执行打包。最终只能是本地打包完，上传 git 仓库。这里有优雅的解决方式的，评论区分享下。\n\n### 3.3 通过 HBuilderX 方式创建的项目，可以使用 npm 吗？\n\n官方文档明确说，可以的\n\n## 4. 生产打包去除`console`\n\n[官方文档](https://uniapp.dcloud.net.cn/collocation/vue-config.html)\n\n```javascript\n// vue.config.js\n\nmodule.exports = {\n  chainWebpack: (config) => {\n    // 发行或运行时启用了压缩时会生效\n    config.optimization.minimizer(\"terser\").tap((args) => {\n      const compress = args[0].terserOptions.compress;\n      // 非 App 平台移除 console 代码(包含所有 console 方法，如 log,debug,info...)\n      compress.drop_console = true;\n      compress.pure_funcs = [\n        \"__f__\", // App 平台 vue 移除日志代码\n        // 'console.debug' // 可移除指定的 console 方法\n      ];\n      return args;\n    });\n  },\n};\n```\n\n## 5. HBuilderX 创建的项目打包时如何区分环境？\n\n意思就是，如何像执行`npm run build:dev`执行的测试环境打包，`npm run build:prod`执行的是生产环境打包。\n\n[官方文档](https://uniapp.dcloud.net.cn/collocation/package.html#%E6%A6%82%E8%BF%B0)\n\n自定义发行-package.json 中添加配置\n\n```json\n{\n  \"uni-app\": {\n    \"scripts\": {\n      \"h5-prod\": {\n        \"title\": \"h5:prod\",\n        \"browser\": \"\",\n        \"env\": {\n          \"UNI_PLATFORM\": \"h5\",\n          \"NODE_ENV\": \"production\",\n          \"DEPLOY_ENV\": \"prod\"\n        },\n        \"define\": {\n          \"CUSTOM-CONST\": true\n        }\n      },\n      \"h5-dev\": {\n        \"title\": \"h5:dev\",\n        \"browser\": \"\",\n        \"env\": {\n          \"UNI_PLATFORM\": \"h5\",\n          \"NODE_ENV\": \"development\",\n          \"DEPLOY_ENV\": \"dev\"\n        },\n        \"define\": {\n          \"CUSTOM-CONST\": true\n        }\n      }\n    }\n  }\n}\n```\n\n添加后，本地开发，就可以在菜单`运行 - h5:dev`本地启动项目，`发行 - 自定义发行 - h5:dev`测试环境打包，当然点击`发行 - 自定义发行 - h5:prod`是生产环境打包。\n\n## 6. 根目录`vue.config.js`中如何获取到自定义 `process` 变量？\n\n因为想在测试环境打包时保留代码中的 debugger 日志，生产环境打包的时候去除日志打印。\n\n像上面定义的`process.env.DEPLOY_ENV`这个变量，业务代码中可以正常获取到，但是在 vue.config.js 这个配置文件中拿不到。\n\n1. 安装`dotenv`\n\n```bash\nnpm i dotenv -D\n```\n\n2. 修改`vue.config.js`\n\n```javascript\nrequire(\"dotenv\").config();\n\nmodule.exports = {\n  chainWebpack(config) {\n    config.when(process.env.NODE_ENV === \"production\", (config) => {\n      // 我们可以拿到process.env.UNI_SCRIPT这个变量来进行操作\n      if (process.env.UNI_SCRIPT === \"h5-prod\") {\n        // https://uniapp.dcloud.io/collocation/vue-config.html\n        // 发行或运行时启用了压缩时会生效\n        config.optimization.minimizer(\"terser\").tap((args) => {\n          const compress = args[0].terserOptions.compress;\n          compress.drop_console = true;\n          compress.pure_funcs = [\n            \"__f__\", // App 平台 vue 移除日志代码\n          ];\n          return args;\n        });\n      }\n    });\n  },\n};\n```\n\n## 7. 打包 h5 过后文件名过长问题\n\n项目稍微大点，页面目录嵌套深一点，打包出来的文件名称巨长，甚至达到 100 字符长度以上。文件名过长，就会带来很恶心的问题，比如被 nginx 拦截，拿不到文件内容，导致页面挂掉。\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.when(process.env.NODE_ENV === \"production\", (config) => {\n      config.output\n        .filename(\"static/js/[name]-[contenthash].js\")\n        .chunkFilename(\"static/js/[id]-[chunkhash].js\");\n    });\n\n    config.optimization.splitChunks({\n      name: function (module, chunks, cacheGroupKey) {\n        const moduleFileName = module\n          .identifier()\n          .split(\"/\")\n          .reduceRight((item) => item);\n        const allChunksNames = chunks.map((item) => item.name).join(\"~\");\n        return `${moduleFileName}`;\n      },\n    });\n  },\n};\n```\n\n## 8. 打包 h5 后`chunk-vendors`文件体积过大，而且页面部署后打开也很慢\n\n庆幸的是，暴露了`vue.config.js`这个文件交给开发者，不然处理起来真的头大。\n\n### 8.1 首先启用`manifest.json`配置文件中的`tree-shaking`配置，“摇掉”那些冗余代码\n\n### 8.2 移除 prefetch 插件\n\n```javascript\n// 这个视自己的项目而定\n// vue.config.js\nmodule.exports = {\n  chainWebpack: (config) => {\n    // 移除 prefetch 插件\n    // https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch\n    config.plugins.delete(\"prefetch\");\n  },\n};\n```\n\n### 8.3 打包进行 gz 或 br 压缩\n\n1. 安装`compression-webpack-plugin`\n\n> 这里有一个问题，7.x 版本后只支持 webpack5.x 版本，这里是 webpack4.x，只能使用 6.x 版本\n> https://github.com/webpack-contrib/compression-webpack-plugin/releases?page=2\n\n```txt\n7.0.0 (2020-12-02)\n\nBREAKING CHANGES\n  minimum supported webpack version is ^5.1.0\n```\n\n安装\n\n```bash\nnpm i compression-webpack-plugin@6.1.1 -D\n```\n\n2. 修改 vue.config.js\n\n```javascript\n// vue.config.js\nconst CompressionPlugin = require(\"compression-webpack-plugin\");\n\nmodule.exports = {\n  configureWebpack: (config) => {\n    if (process.env.NODE_ENV === \"production\") {\n      config.plugins.push(\n        new CompressionPlugin({\n          filename: \"[path][base].gz\",\n          algorithm: \"gzip\",\n          test: /\\.(js|css|html)$/,\n          threshold: 10240,\n          minRatio: 0.8,\n          deleteOriginalAssets: false,\n        })\n      );\n    }\n  },\n};\n```\n\n3. 同时 nginx 开启 gzip\n\n```nginx\nserver {\n  gzip on; #开启gzip\n  # gzip_buffers 32 4k; #设置压缩所需要的缓冲区大小，以4k为单位，如果文件为32k则申请32*4k的缓冲区\n  gzip_comp_level 6; #gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间\n  gzip_min_length 4000; #gizp压缩起点，文件大于4k才进行压缩\n  gzip_vary on; # 是否在http header中添加Vary: Accept-Encoding，建议开启\n  gzip_static on; #nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩\n  # gzip_types text/xml text/javascript application/javascript text/css text/plain application/json application/x-javascript; # 进行压缩的文件类型\n}\n```\n\n### 8.4 结合`webpack-bundle-analyzer`生成的模块分析图来拆分 chunk-vendors\n\n#### 8.4.1 安装`webpack-bundle-analyzer`\n\n```bash\nnpm i webpack-bundle-analyzer -D\n```\n\n#### 8.4.2 引入`webpack-bundle-analyzer`\n\n```javascript\nconst BundleAnalyzerPlugin =\n  require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n\nmodule.exports = {\n  configureWebpack: (config) => {\n    config.plugins.push(new BundleAnalyzerPlugin());\n  },\n};\n```\n\n如下图所示,chunk-vendors 的组成，是把那些公共的依赖全部都打包在一起了，文件大小达到 1M 以上，严重影响页面加载速度，生成环境上 gzip 压缩后，首页加载也需要将近 10s 左右，令人汗颜。(这里的拆分视具体项目而定)\n\n![ ](../img/uniapp/old-chunk-vendors.png)\n\n- 需要将`@dcloudio`(658kb)拆分为\"uni-h5\"部分和\"vue-cli-plugin-uni\"部分\n- 将`core-js`(282kb)单独拆出来\n- 将`node-rsa`(112kb)单独拆出来\n- 将`bn.js`(88kb)单独拆出来\n- ...\n\n入口 index 文件也达到了几乎 350kb，里面有一个大的 pages.json 文件\n\n![ ](../img/uniapp/old-index.png)\n\n- 将`pages.json`(290kb)单独拆出来\n\n在浏览器上看 chunk-vendors，还有一个`buffer`模块\n\n![ ](../img/uniapp/old-chunk-vendors-js.png)\n\n- 将`buffer`模块单独拆出来\n\n#### 8.4.3 `optimization.splitChunks`拆分模块\n\n> 这里是 webpack4\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.optimization.splitChunks({\n      chunks: \"all\", // 必须三选一： \"initial\"(同步包) | \"all\"(推荐，同步或异步包) | \"async\" (默认就是async，异步包)\n      automaticNameDelimiter: \"~\", // 打包分隔符\n      name: function (module, chunks, cacheGroupKey) {\n        const moduleFileName = module\n          .identifier()\n          .split(\"/\")\n          .reduceRight((item) => item);\n        const allChunksNames = chunks.map((item) => item.name).join(\"~\");\n        return `${moduleFileName}`;\n      },\n      cacheGroups: {\n        vendors: {\n          name: \"chunk-vendors\",\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true, // 遇到重复包直接引用，不重新打包\n          priority: 0, // 打包优先级权重值\n          // minChunks: 1,  // 引用超过一次直接打包到chunk中\n          minSize: 30000,\n        },\n        pages: {\n          name: \"chunk-pages\",\n          test: /pages\\.json$/,\n          chunks: \"all\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 90,\n          minChunks: 1,\n          minSize: 10000,\n        },\n        \"node-rsa\": {\n          name: \"chunk-node-rsa\",\n          test: /node-rsa/,\n          chunks: \"all\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 70,\n        },\n        buffer: {\n          name: \"chunk-buffer\",\n          test: /buffer|is-buffer/,\n          chunks: \"all\",\n          reuseExistingChunk: true,\n          priority: 90,\n          minChunks: 1,\n          minSize: 15000,\n          enforce: true,\n        },\n        \"core-js\": {\n          name: \"chunk-core-js\",\n          test: /core-js/,\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 70,\n        },\n        \"uni-h5\": {\n          name: \"chunk-uni-h5\",\n          test: /uni-h5/,\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 80,\n        },\n        vue: {\n          name: \"chunk-vue\",\n          test: /vue-cli-plugin-uni/,\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 85,\n        },\n        bn: {\n          name: \"chunk-bn\",\n          test: /bn/,\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 70,\n        },\n      },\n    });\n\n    // 提取公共的runtime\n    config.optimization.runtimeChunk(\"single\");\n  },\n};\n```\n\n#### 8.4.4 拆分的 chunk 没有在`index.html`中自动引入\n\n> 打包很成功，没任何报错，但是在运行项目的时候，页面一片空白，没任何 ui 展示。**问题就出在，拆分出来的各个小 chunk，没有自动在 index.html 中引入**，我们可以在打包出来的 unpackage 目录，本地启动一个静态服务，把那些 chunk 手动引入，刷新页面，页面 ui 显示出来了\n\n**所以我们需要找到[html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)的配置，把我们单独拆分出来的 chunk，添加到`chunks`配置中**\n\n```javascript\n// vue.config.js\nfunction changeHtmlWebpackPluginChunks(config) {\n  const plugins = config.plugins;\n  const chunkArr = [\n    \"runtime\",\n    \"chunk-vue\",\n    \"chunk-uni-h5\",\n    \"chunk-core-js\",\n    \"chunk-node-rsa\",\n    \"chunk-buffer\",\n    \"chunk-bn\",\n    \"chunk-pages\",\n  ];\n\n  plugins.forEach((item, index) => {\n    // 为HtmlWebpackPlugin\n    if (\n      item.options &&\n      Object.prototype.toString.call(item.options) === \"[object Object]\" &&\n      Object.hasOwnProperty.call(item.options, \"filename\") &&\n      Object.hasOwnProperty.call(item.options, \"chunks\") &&\n      item.options.filename === \"index.html\"\n    ) {\n      const oldChunks = item.options.chunks || [];\n      // 修改chunks引入\n      item.options.chunks = [...chunkArr, ...oldChunks];\n    }\n  });\n}\n\nmodule.exports = {\n  configureWebpack: (config) => {\n    if (process.env.NODE_ENV === \"production\") {\n      changeHtmlWebpackPluginChunks(config);\n    }\n  },\n};\n```\n\n下图是拆分后 chunk-vendors，和之前对比，那些大模块都被拆分出去了，文件体积也从 1M 多变成了 320kb，首页加载也从 10s 多变成了 3s 左右。\n\n![ ](../img/uniapp/new-chunk-vendors.png)\n\n#### 8.4.5 关于拆分 vendors 后，`uview-ui`部分组件报错\n\n> 项目中使用到了`uview-ui`ui 框架\n\n重新打包，本地再次启动项目，浏览器控制台发现如下报错\n\n![ ](../img/uniapp/console.png)\n\n再到 unpackage 目录一看，居然还有`u-icon.vue`和`u-line.vue`未打包！\n\n那单独提取这两个文件为 chunk 进行打包，再次打包后启动项目，这两个组件没报错，其他组件报错了，unpackage 目录里出现了更多的\"u-xx.vue\"组件，这是什么情况？\n\n猜测是引入 uview-ui 框架时的[easycom 组件模式](https://v1.uviewui.com/components/npmSetting.html)惹得鬼，我尝试着在 easycom 里添加自定义`custom`配置，把这两个组件写在里面，但是不管用。页面不报错，但是样式出问题了。。。\n\n或者直接删除 easycom 配置进行，启动项目，页面样式出问题了。。。\n\n最终还是在`splitChunks`里单独提取 uview-ui 为 chunk，这样问题是解决了，但是这样在入口的时候，就要加载一个提取出来的 uview-ui(项目中使用到的所有 uview-ui 组件，并非整个 uview-ui)。未拆分前，每个页面只需加载自己所需的组件，现在把所有页面的组件都提取出来了，等于是每个页面都加载了冗余的 uview-ui 组件。好在是最终页面加载速度是比之前快了。\n\n这里有知道怎么处理的，或者有遇到相同问题的，分享下怎么处理。\n\n#### 8.4.6 拆分为各个小 chunk 后，页面 js 请求变多了\n\n![ ](../img/uniapp/new-console.png)\n\n页面 js 请求变多，对页面性能也有一定影响，所以这里拆分，视具体项目而定。\n\n## 9. hbuilderx 创建的项目,h5 持续部署\n\n> 这里视公司内部情况而定，我这是服务器上有现成的 nginx,也无需自己打包 docker 镜像\n\n1. `.gitlab.yml`\n\n> SSH_USERNAME,SSH_HOST,SSH_PASSWORD 这 3 个变量写在项目`Setting->CI/CD->Variables`里\n\n```yml\nstages:\n  - build\n\njob_build:\n  stage: build\n  script:\n    # - sudo docker image build -t demo_h5 .\n    # - sudo docker tag demo_h5 registry.cn-hangzhou.aliyuncs.com/test-blog/demo_h5:latest\n    # - sudo docker login --username=$ALIYUN_DOCKER_NAME registry.cn-hangzhou.aliyuncs.com --password=$ALIYUN_DOCKER_PASSWORD\n    # - sudo docker push registry.cn-hangzhou.aliyuncs.com/test-blog/demo_h5:latest\n    # - sudo docker logout\n    - if yum list installed | grep 'sshpass'; then echo yes; else yum -y install sshpass;fi\n    - sh deploy.sh $SSH_USERNAME $SSH_HOST $SSH_PASSWORD\n  tags:\n    # 公司内部gitlab注册一个runner,或者写一个公共runner\n    - xxxx\n  only:\n    - main\n```\n\n2. `deploy.sh`\n\n> 将打包出来的文件，上传到服务器指定目录，然后页面就可以访问了\n>\n> 为什么要将打包出来的代码进行压缩，因为打包出来的文件数量很多，如果一个个传输，会非常慢，所以要进行压缩后变成 1 个文件进行传输\n\n```sh\n#!/bin/bash\n\necho \"ssh deploy start==>\"\n# echo \"$3\" ssh \"$1\"@\"$2\" --password-stdin\n\nusername=$1\nhost=$2\npassword=$3\n# 打包目录\ndir=\"./unpackage/dist/build/h5\"\n# 服务器目录\ntarget=\"/home/demo_h5/nginx/html/app-web\"\n\n# 上传本地文件到服务器\n# scp /path/filename username@servername:/path\n# 上传目录到服务器\n# scp -r local_dir username@servername:remote_dir\n\n# sshpass -p ${password} scp ${dir}/index.html ${username}@${host}:/home/demo_h5/nginx/html/app-web\n# sshpass -p ${password} scp -r ${dir}/static ${username}@${host}:/home/demo_h5/nginx/html/app-web\n\n# cd到指定目录\ncd ${dir}\n# 压缩所有文件并重命名\nzip -r -q -o build.zip ./\n# 通过sshpass上传压缩文件到指定目录\nsshpass -p ${password} scp ./build.zip ${username}@${host}:${target}\nsleep 2\n\n# 登录远程服务器\n# cd 到指定目录\n# unzip 解压到指定目录\n#   -o 不必先询问用户，unzip执行后覆盖原有文件。\n#   -d 解压到指定目录\n# 删除压缩文件\n\nsshpass -p ${password} ssh ${username}@${host} \"cd /home/demo_h5/nginx/html/app-web && pwd && unzip -o -q ./build.zip -d ./ && rm -rf ./build.zip\"\n\necho \"ssh deploy end==>\"\n```\n\n3. git 提交代码\n\n不出意外，代码自动部署到相应位置，浏览器可以访问了\n\n```log\n$ if yum list installed | grep 'sshpass'; then echo yes; else yum -y install sshpass;fi\nRepository base is listed more than once in the configuration\nRepository updates is listed more than once in the configuration\nRepository extras is listed more than once in the configuration\nRepository centosplus is listed more than once in the configuration\nRepodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast\nsshpass.x86_64                              1.06-2.el7                 @extras\nyes\n$ sh deploy.sh $SSH_USERNAME $SSH_HOST $SSH_PASSWORD\nssh deploy start==>\n/home/demo_h5/nginx/html/app-web\nssh deploy end==>\nJob succeeded\n```\n\n## 10. 参考资料\n\n1. [uniapp 官方文档](https://uniapp.dcloud.net.cn/)\n2. [webpack4 官方文档](https://v4.webpack.docschina.org/concepts/)\n3. [vue-cli 官方文档](https://cli.vuejs.org/zh/guide/)\n"},{"id":"2IIBDhrJ-1eTRaQxbjZCg","title":"Taro与微信小程序原生组件之间的事件通信","keywords":["taro"," wemark"],"date":"2022-04-04 18:02:42","fileName":"taro-wemark","content":"\n- [小程序博客 github 仓库](https://github.com/sRect/wechat-blog)\n\n- [本小程序链接](#小程序://sRect的个人博客/sRect的个人博客/Z1MPSUtT7bnfPFd)\n\n## 1. 需求背景\n\n最近在做一个微信小程序版的简易博客，原本是准备自己解析`markdown`并渲染，最后还是使用了[`wemark`](https://github.com/TooBug/wemark)第三方组件来渲染，因为自己解析渲染的很难看。\n\n因为小程序内打开第三方链接，需要在项目配置里设置域名才能打开，对于第三方网站链接很无奈，所以干脆直接进行复制，然后可以自行通过浏览器打开。\n\n```javascript\nconst Detail = () => {\n  const mdStr = `...`;\n\n  return (\n    <View id=\"md\" className=\"markdown-body\">\n      <wemark id=\"wemark\" md={mdStr} link highlight type=\"wemark\" />\n    </View>\n  );\n};\n```\n\n![ ](../img/taro-wemark/link.png)\n\n如上图显示，就是想在点击的时候，拿到链接里的 url。\n\n其实熟悉微信小程序的开发，这是一个很简单的需求，但我等彩笔不熟悉。😄\n\n原本还想拿到 dom，然后自己绑定事件，最后发现这样错的离谱。\n\n## 2. 彩笔的错误之路\n\n> **注意**： 以下几种方式都没成功\n\n### 2.1 使用`createSelectorQuery`api\n\n> 打印出来，都没有想要的结果，没法继续下去\n\n```javascript\nimport Taro, { useReady } from \"@tarojs/taro\";\n\nconst Detail = () => {\n  useReady(() => {\n    Taro.createSelectorQuery()\n      .select(\"#md\")\n      .node((res) => {\n        console.log(\"==>\");\n        console.log(res);\n      })\n      .exec();\n  });\n};\n```\n\n或者\n\n```javascript\nuseReady(() => {\n  const query = Taro.createSelectorQuery().in(this);\n\n  query\n    .select(\"#md\")\n    .node(function (res) {\n      console.log(res.node);\n    })\n    .exec();\n});\n```\n\n### 2.2 使用`getCurrentInstance`api\n\n> 打印出来，也没有想要的，无法继续下去\n\n```javascript\nimport { getCurrentInstance } from \"@tarojs/taro\";\n\nconst { page } = getCurrentInstance();\nconst md = page.selectComponent(\"#md\");\n\nconsole.log(md);\n```\n\n### 2.3 直接在最外面绑定事件\n\n> 打印出来，无法区分是否点击在链接上，也无法继续下去\n\n```javascript\nconst Detail = () => {\n  const mdStr = `...`;\n\n  useEffect(() => {\n    const el = document.getElementById(\"md\");\n    function handleClick(event) {\n      console.log(event);\n    }\n    el.addEventListener(\"tap\", handleClick);\n\n    return () => {\n      el.removeEventListener(\"tap\", handleClick);\n    };\n  }, []);\n\n  return (\n    <View id=\"md\" className=\"markdown-body\">\n      <wemark id=\"wemark\" md={mdStr} link highlight type=\"wemark\" />\n    </View>\n  );\n};\n```\n\n## 3. 解决\n\n> 还是得到`wemark`组件里去修改\n\n- `wemark/wemark.js`添加如下代码\n\n```javascript\nComponent({\n  methods: {\n    onTap: function (e) {\n      console.log(\"onTap==>\", e);\n      this.triggerEvent(\"myevent\", e);\n    },\n  },\n});\n```\n\n- `wemark/wemark.wxml`中添加`data-url`和添加事件绑定\n\n```html\n<navigator\n  class=\"wemark_inline_link\"\n  url=\"{{renderInline.data.href}}\"\n  wx:if=\"{{renderInline.type === 'link'}}\"\n  data-url=\"{{renderInline.data.href}}\"\n  bindtap=\"onTap\"\n>\n  {{renderInline.content}}\n</navigator>\n```\n\n- 回到自己代码中修改\n\n```javascript\nconst Detail = () => {\n  const mdStr = `...`;\n\n  // 链接复制\n  const onMyEvent = (e) => {\n    console.log(e);\n\n    const str = e?.detail?.currentTarget?.dataset?.url;\n\n    if (!str) return;\n\n    Taro.setClipboardData({\n      data: str,\n      success() {\n        Taro.showToast({\n          title: \"链接复制成功\",\n          icon: \"success\",\n        });\n      },\n    });\n  };\n\n  return (\n    <View id=\"md\" className=\"markdown-body\">\n      <wemark\n        id=\"wemark\"\n        md={mdStr}\n        link\n        highlight\n        type=\"wemark\"\n        onMyevent={onMyevent}\n      />\n    </View>\n  );\n};\n```\n\n![ ](../img/taro-wemark/dataset.png)\n\n- 至此，解决了这个小需求\n\n## 4. 参考链接\n\n1. [组件间通信与事件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html)\n\n2. [原生项目使用 Taro](https://taro-docs.jd.com/taro/docs/taro-in-miniapp/#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6)\n"},{"id":"hs5LJd5JPsZK6IjHkpOk7","title":"mermaid使用","keywords":["mermaid"],"date":"2022-3-11 16:28:48","fileName":"mermaid","content":"\nmermaid 流程图 + 饼图使用\n\n# img\n\n![img](../img/mermaid/test5.png)\n\n## table\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :----- | -----: | :------: |\n| 单元格 | 单元格 |  单元格  |\n| 单元格 | 单元格 |  单元格  |\n\n## 流程图\n\n```mermaid\nflowchart TB\nA[Hard] -->|Text| B(Round)\nB --> C{Decision}\nC -->|One| D[Result 1]\nC -->|Two| E(Result 2)\n```\n\n## 饼图\n\n> https://mermaid-js.github.io/mermaid/#/pie\n\n```mermaid\npie\ntitle Pets adopted by volunteers\n\"Dogs\" : 386\n\"Cats\" : 85\n\"Rats\" : 15\n```\n\n## 参考\n\n1. [mermaid](https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md)\n"},{"id":"YTykUQigYehQ2DjiY16uS","title":"微信小程序持续获取定位测试","keywords":["微信小程序"," Tarojs"],"date":"2021-11-03","fileName":"location","content":"\n- [github 源码仓库](https://github.com/sRect/taro_wx)\n\n### 1. 客户端详情\n\n> 文章内使用 Tarojs 开发微信小程序\n\n- 手机型号：小米 10\n- 操作系统及版本：Android 10\n- 客户端平台：android\n- SDKVersion：2.20.2\n\n### 2. 注意点\n\n1. taro 项目配置文件`src/app.config.js`中要添加以下配置\n\n```javascript\nexport default {\n  requiredBackgroundModes: [\"location\"],\n  permission: {\n    \"scope.userLocation\": {\n      desc: \"如实填写实际用途\", // 高速公路行驶持续后台定位\n    },\n  },\n};\n```\n\n2. 检查手机是否打开位置信息开关\n\n```javascript\nTaro.getSystemInfoAsync({\n  success(data) {\n    console.log(data.locationEnabled);\n  },\n});\n```\n\n3. 检查是否给微信开了定位权限\n\n```javascript\nTaro.getSystemInfoAsync({\n  success(data) {\n    console.log(data.locationAuthorized);\n  },\n});\n```\n\n4. 检查当前小程序是否开了后台定位权限\n\n```javascript\nTaro.getSetting({\n  success(res) {\n    const authSetting = res.authSetting;\n    if (\n      !authSetting[\"scope.userLocation\"] ||\n      !authSetting[\"scope.userLocationBackground\"]\n    ) {\n      // 让用户在弹出的选项中务必勾选“使用小程序期间和离开小程序之后”选项\n      Taro.openSetting();\n    }\n  },\n});\n```\n\n### 3. 完整代码\n\n```jsx\nimport React, { useState } from \"react\";\nimport Taro, { useReady, useDidShow, useDidHide } from \"@tarojs/taro\";\nimport { View, Map } from \"@tarojs/components\";\n\nconst hasOwnProperty = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nconst HandleLocation = () => {\n  const [systemSetting, setSystemSetting] = useState({});\n  const [location, setLocation] = useState({ longitude: \"\", latitude: \"\" });\n  const [locationList, setLocationList] = useState([]);\n\n  const handleGetLocation = () => {\n    if (Taro.canIUse(\"startLocationUpdateBackground\")) {\n      // https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html\n      // 小程序全局配置\n      // https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#permission\n      // wx.authorize({scope: \"scope.userInfo\"})，不会弹出授权窗口，请使用 <button open-type=\"getUserInfo\"/>\n      // 需要授权 scope.userLocation、scope.userLocationBackground 时必须配置地理位置用途说明\n\n      Taro.startLocationUpdateBackground({\n        success() {\n          Taro.onLocationChange((data) => {\n            setLocationList((pre) => [...pre, data]);\n\n            setLocation({ longitude: data.longitude, latitude: data.latitude });\n\n            // ajax发送数据到后台\n            // ...\n          });\n        },\n        fail(err) {\n          console.log(err);\n          Taro.showToast({\n            icon: \"error\",\n            title: \"定位失败\",\n          });\n\n          Taro.openSetting();\n        },\n      });\n    } else {\n      Taro.showToast({\n        icon: \"error\",\n        title: \"您的设备暂不支持定位\",\n      });\n    }\n  };\n\n  // 检查手机是否打开位置信息开关\n  // 检查是否给微信开了定位权限\n  const checkMobileLocationAuth = () => {\n    return new Promise((resolve, reject) => {\n      Taro.getSystemInfoAsync({\n        success(data) {\n          setSystemSetting(data);\n\n          if (\n            data &&\n            hasOwnProperty(data, \"locationEnabled\") &&\n            !data.locationEnabled\n          ) {\n            Taro.showModal({\n              title: \"提示\",\n              content: \"请打开手机设置-位置信息(GPS)开关\",\n              confirmText: \"确定\",\n              showCancel: false,\n            });\n\n            reject();\n          }\n\n          if (\n            data &&\n            hasOwnProperty(data, \"locationAuthorized\") &&\n            !data.locationAuthorized\n          ) {\n            Taro.showModal({\n              title: \"提示\",\n              content:\n                \"请打开手机设置-应用设置-应用管理-微信-权限管理-定位权限开关\",\n              confirmText: \"确定\",\n              showCancel: false,\n              success() {\n                // Taro.openSetting();\n              },\n            });\n\n            reject();\n          }\n\n          resolve();\n        },\n        fail() {\n          reject();\n        },\n      });\n    });\n  };\n\n  // 检查当前小程序是否开了定位权限\n  const checkMiniAppLocationAuth = () => {\n    return new Promise((resolve, reject) => {\n      if (!Taro.canIUse(\"getSetting\")) return reject();\n\n      Taro.getSetting({\n        success: function (res) {\n          const authSetting = res.authSetting;\n\n          if (\n            authSetting &&\n            hasOwnProperty(authSetting, \"scope.userLocation\") &&\n            hasOwnProperty(authSetting, \"scope.userLocationBackground\") &&\n            authSetting[\"scope.userLocation\"] &&\n            authSetting[\"scope.userLocationBackground\"]\n          ) {\n            resolve();\n          } else {\n            if (Taro.canIUse(\"openSetting\")) {\n              Taro.showModal({\n                title: \"提示\",\n                content:\n                  \"请在点击确定后，在弹出的选项中务必勾选“使用小程序期间和离开小程序之后”选项\",\n                confirmText: \"确定\",\n                showCancel: false,\n                success() {\n                  Taro.openSetting();\n                },\n              });\n            } else {\n              Taro.showModal({\n                title: \"提示\",\n                content:\n                  \"请点击右上角“...”更多-设置-位置信息，在弹出的选项中务必勾选“使用小程序期间和离开小程序之后”选项\",\n                confirmText: \"确定\",\n                showCancel: false,\n              });\n            }\n\n            reject();\n          }\n        },\n      });\n    });\n  };\n\n  useReady(() => {\n    console.log(\"useReady==>\");\n  });\n\n  useDidShow(() => {\n    console.log(\"useDidShow==>\");\n    if (Taro.canIUse(\"stopLocationUpdate\")) {\n      Taro.stopLocationUpdate({\n        complete() {\n          checkMobileLocationAuth()\n            .then(checkMiniAppLocationAuth)\n            .then(() => {\n              // 全部ok，可以进行持续定位\n              handleGetLocation();\n            })\n            .catch(() => {\n              console.log(\"err==>\");\n            });\n        },\n      });\n    }\n  });\n\n  useDidHide(() => {\n    console.log(\"useDidHide==>\");\n  });\n\n  return (\n    <View>\n      <Map\n        style=\"width: 100%; height: 200px;\"\n        scale={16}\n        longitude={location.longitude}\n        latitude={location.latitude}\n      />\n    </View>\n  );\n};\n```\n\n### 4. 总结\n\n- 经过本地开发实际测试，把小程序切到后台后，切换到其他 app\n- 或者手机直接锁屏\n\n以上两种情况，1 分钟后，`startLocationUpdateBackground`api 即失效，只有重新解锁手机，重新回到微信，api 的实时位置监控才被唤醒，尚未找到解决方法\n\n### 5. 其他\n\n钉钉小程序`dd.getLocation`只有当前钉钉小程序当前在激活状态下可以获取到，切换到后台和手机锁屏后，即失效\n\n### 6. 参考资料\n\n1. [微信小程序授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)\n2. [微信小程序全局配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#permission)\n"},{"id":"z4jpUDowXlaR6AHk368aK","title":"微前端qiankun上手体验","keywords":["微前端"," single-spa"," qiankun"],"date":"2021-02-25","fileName":"qiankun","content":"\n> 1. [qiankun 官方文档](https://qiankun.umijs.org/zh)\n> 2. [single-spa](https://zh-hans.single-spa.js.org/docs/getting-started-overview/)\n> 3. [微前端-最容易看懂的微前端知识](https://juejin.cn/post/6844904162509979662#heading-0)\n\n微前端的类型：\n\n1. 受路由控制渲染的子应用\n2. 不受路由控制的组件\n3. 非渲染组件，应用间通信逻辑\n\n### 1.子应用-vue\n\n#### 1. vue-cli 创建子应用\n\n```shell\nvue create qiankun_vue\n```\n\n#### 2. 修改入口`main.js`文件\n\n```javascript\n// https://qiankun.umijs.org/zh/guide/tutorial#vue-微应用\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\nimport router from \"./router\";\n\n// Vue.config.productionTip = false\n\nlet vueInstance = null;\nfunction render(props = {}) {\n  const { container } = props;\n\n  vueInstance = new Vue({\n    router,\n    render: (h) => h(App),\n    // 这里是挂载到自己的html上，基座会拿到这个挂载后的html，将其插入到相应的容器里\n\n    // Application died in status NOT_MOUNTED: Target container with #container not existed after xxx mounted!\n    // 微应用的根 id 与其他 DOM 冲突。解决办法是：修改根 id 的查找范围。\n  }).$mount(container ? container.querySelector(\"#app\") : \"#app\");\n}\n\n// 使用 webpack 运行时 publicPath 配置\n// 动态设置publicPath\nif (window.__POWERED_BY_QIANKUN__) {\n  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n}\n\n// https://qiankun.umijs.org/zh/faq#如何独立运行微应用？\nif (!window.__POWERED_BY_QIANKUN__) {\n  render();\n}\n\n// 暴露3个异步方法 bootstrap mount unmount\nexport async function bootstrap(props) {}\nexport async function mount(props) {\n  console.log(\"props=====>\", props);\n  render(props);\n}\nexport async function unmount(props) {\n  vueInstance && vueInstance.$destroy();\n}\n```\n\n#### 3. 修改路由`router/index.js`文件\n\n```diff\n  const router = new VueRouter({\n    mode: 'history',\n-    base: process.env.BASE_URL,\n+    base: window.__POWERED_BY_QIANKUN__ ? '/vue' : process.env.BASE_URL,\n    routes\n  })\n\n```\n\n#### 4. 根目录新建`vue.config.js`，修改打包配置\n\n```javascript\nmodule.exports = {\n  devServer: {\n    port: 8000,\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n    },\n  },\n  // https://webpack.docschina.org/configuration/output/#outputlibrary\n  configureWebpack: {\n    output: {\n      library: \"vueApp\", // 打包成一个类库\n      libraryTarget: \"umd\", // umd最终会把bootstrap/mount/unmount挂载到window上\n    },\n  },\n};\n```\n\n### 2.子应用-react\n\n#### 1. create-react-app 创建子应用\n\n```\ncreate-react-app qiankun_react\n```\n\n#### 2. 修改入口`index.js`文件\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter, Link, Route } from \"react-router-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n// import reportWebVitals from './reportWebVitals';\n\nfunction render(props) {\n  const { container } = props;\n  // https://reactrouter.com/web/api/BrowserRouter\n  ReactDOM.render(\n    <React.StrictMode>\n      <BrowserRouter basename=\"/react\">\n        <Link to=\"/\">react-home</Link> |<Link to=\"/about\">react-about</Link>\n        {/* exact 严格模式 */}\n        <Route path=\"/\" exact render={() => <App />}></Route>\n        <Route\n          path=\"/about\"\n          exact\n          render={() => <div>react about page</div>}\n        ></Route>\n      </BrowserRouter>\n    </React.StrictMode>,\n    container\n      ? container.querySelector(\"#root\")\n      : document.querySelector(\"#root\")\n  );\n}\n\n// 独立运行\nif (!window.__POWERED_BY_QIANKUN__) {\n  render();\n}\n\nexport async function bootstrap(props) {}\nexport async function mount(props) {\n  render(props);\n}\nexport async function unmount(props) {\n  const { container } = props;\n  ReactDOM.unmountComponentAtNode(\n    container\n      ? container.querySelector(\"#root\")\n      : document.querySelector(\"#root\")\n  );\n}\n```\n\n#### 3. 修改打包配置文件\n\n##### 1. 安装`react-app-rewired`\n\n```shell\nyarn add react-app-rewired -D\n```\n\n##### 2. 子应用根目录新建`config-overrides.js`文件\n\n```javascript\n// https://github.com/timarney/react-app-rewired/blob/HEAD/README_zh.md#扩展配置选项\nmodule.exports = {\n  webpack: (config) => {\n    config.output.library = \"reactApp\";\n    config.output.libraryTarget = \"umd\";\n    config.output.publicPath = \"http://localhost:9000/\";\n    return config;\n  },\n  devServer: (configFunc) => {\n    return (proxy, allowedHost) => {\n      const config = configFunc(proxy, allowedHost);\n      // 设置开发服务允许跨域\n      config.headers = {\n        \"Access-Control-Allow-Origin\": \"*\",\n      };\n\n      return config;\n    };\n  },\n};\n```\n\n##### 3. 设置环境变量\n\n1. 子应用根目录新建`.env`文件\n\n```\nPORT=4000\nWDS_SOCKET_PORT=4000\n```\n\n或者在`package.json`启动脚本中修改端口\n\n```diff\n \"scripts\": {\n-     \"start\": \"react-app-rewired start\",\n+     \"start\": \"set PORT=4000 && react-app-rewired start\",\n   },\n```\n\n2. 修改`package.json`文件\n\n```diff\n \"scripts\": {\n-     \"start\": \"react-scripts start\",\n-     \"build\": \"react-scripts build\",\n-     \"test\": \"react-scripts test\",\n-     \"eject\": \"react-scripts eject\"\n+     \"start\": \"react-app-rewired start\",\n+     \"build\": \"react-app-rewired build\",\n+     \"test\": \"react-app-rewired test\",\n+     \"eject\": \"react-app-rewired eject\"\n   },\n```\n\n### 3.子应用(非 webpack 构建)-jquery+bootstrap\n\n#### 1. 新建`index.html`文件\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>Bootstrap 101 Template</title>\n    <link href=\"//localhost:5000/lib/bootstrap.min.css\" rel=\"stylesheet\" />\n  </head>\n  <body>\n    <div class=\"container\" id=\"app\">\n      <h1>你好，世界！</h1>\n      <div class=\"row\">\n        <div class=\"input-group\">\n          <span class=\"input-group-addon\" id=\"basic-addon1\">@</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"Username\"\n            aria-describedby=\"basic-addon1\"\n          />\n        </div>\n      </div>\n    </div>\n    <script src=\"//localhost:5000/lib/jquery.min.js\"></script>\n    <script src=\"//localhost:5000/lib/bootstrap.min.js\"></script>\n    <!--  entry js为入口文件 -->\n    <script src=\"//localhost:5000/entry.js\"></script>\n  </body>\n</html>\n```\n\n#### 2. 新建`entry.js`入口文件\n\n```javascript\nconst render = ($) => {\n  $(\"#purehtml-container\").html(\"Hello, render with jQuery\");\n  return Promise.resolve();\n};\n((global) => {\n  global[\"purehtml\"] = {\n    bootstrap: () => {\n      console.log(\"purehtml bootstrap\");\n      return Promise.resolve();\n    },\n    mount: () => {\n      console.log(\"purehtml mount\");\n      return render($);\n    },\n    unmount: () => {\n      console.log(\"purehtml unmount\");\n      return Promise.resolve();\n    },\n  };\n})(window);\n```\n\n### 4.基座应用-vue\n\n#### 1.修改入口`main.js`文件\n\n```diff\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\n+ import { registerMicroApps, start } from 'qiankun';\n+ import ElementUI from 'element-ui';\n+ import 'element-ui/lib/theme-chalk/index.css';\n\nVue.config.productionTip = false\n\n+ Vue.use(ElementUI);\n\n+ const apps = [\n+   {\n+     name: \"vueApp\",\n+     // 默认通过fetch加载这个html，解析里面的js，动态的执行\n+     // 注意：子应用必须支持跨域\n+     entry: \"http://localhost:8000\",\n+     container: \"#vueDOM\", // 容器名\n+     activeRule: \"/vue\", // 激活路径\n+     props: { a: 1, b: 2 }, // 传给子应用的参数\n+   },\n+   {\n+     name: \"reactApp\",\n+     entry: \"//localhost:9000\",\n+     container: \"#react\",\n+     activeRule: \"/react\",\n+   },\n+   {\n+     name: \"jqueryApp\",\n+     entry: \"//localhost:5000\",\n+     container: \"#jquery\",\n+     activeRule: \"/jquery\",\n+     props: { a: 100, b: 200 },\n+   },\n+ ];\n+\n+ registerMicroApps(apps); // 注册应用\n+ // 启动应用\n+ start({\n+   // https://qiankun.umijs.org/zh/api#startopts\n+   prefetch: false, // 取消预加载\n+ });\n\nnew Vue({\n  router,\n  render: h => h(App)\n}).$mount('#app')\n```\n\n#### 2. 修改`App.vue`组件\n\n```html\n<template>\n  <div id=\"app\">\n    <el-menu :router=\"true\" mode=\"horizontal\">\n      <!-- 基座自己的路由 -->\n      <el-menu-item index=\"/\">base-home</el-menu-item>\n      <el-menu-item index=\"/about\">base-about</el-menu-item>\n      <!-- 引用其他子应用 -->\n      <el-menu-item index=\"/vue\">vue 应用</el-menu-item>\n      <el-menu-item index=\"/react\">react 应用</el-menu-item>\n      <el-menu-item index=\"/jquery\">jquery + bootstrap 应用</el-menu-item>\n    </el-menu>\n\n    <router-view />\n\n    <div id=\"vueDOM\"></div>\n    <div id=\"react\"></div>\n    <div id=\"jquery\"></div>\n  </div>\n</template>\n```\n"}]}