{"list": [{"id":"9a5CggpRC5uwPHfMfWFAl","title":"仿抖音左右歪头图片选择","keywords":["face-api"," 人脸识别"," 抖音"],"date":"2022-11-29","fileName":"face-api","content":"\n- [在线体验](https://srect.github.io/face-api.js)\n\n- [项目 github 仓库](https://github.com/sRect/face-api.js/tree/dy)\n\n> 前一阵子在刷抖音时，看到一个通过左右歪头选择两侧图片的视频，感觉很有趣。顿时想到了 n 年前的[**face-api.js**](https://github.com/justadudewhohacks/face-api.js)，那就基于这个来做吧。总体做好后，有很多细节需要改进，不够细腻丝滑。\n\n### 1. 需求分析\n\n直接开搞吧！\n\n1. 页面基本布局，左右两侧图片，而且有缩放和移动动画\n2. 需要打开摄像头，获取视频流，通过 video 展现出来\n3. 需要检测人脸是向哪一侧歪头\n\n### 2. 具体实现\n\n#### 2.1 页面布局和 animation 动画\n\n这个不难，布局好后，就是添加 css 动画，我这里写的很粗糙，不细腻，但勉强能用，例如下面 _leftHeartMove_ 为中间的小爱心向左侧移动动画\n\n```css\n.heart {\n  width: 30px;\n  height: 30px;\n  padding: 4px;\n  box-sizing: border-box;\n  border-radius: 50%;\n  background-color: #fff;\n  position: absolute;\n  top: -15px;\n  left: 50%;\n  transform: translateX(-50%) rotateZ(0deg) scale(1);\n  animation: leftHeartMove 0.5s linear;\n  animation-fill-mode: forwards;\n  z-index: 2;\n}\n\n@keyframes leftHeartMove {\n  from {\n    top: -15px;\n    left: 50%;\n    transform: translateX(-50%) rotateZ(0deg) scale(1);\n  }\n\n  to {\n    top: 65px;\n    left: -13%;\n    transform: translateX(-50%) rotateZ(-15deg) scale(1.2);\n  }\n}\n```\n\n#### 2.2 打开摄像头并显示\n\n**注意点**\n\n1. 关于 h5`navigator.mediaDevices.getUserMedia` 这个 api，本地开发`localhost`是可以拉起摄像头打开提示的，线上部署必须是`https`节点才行，`http`不能唤起打开摄像头\n\n![](../img/face-api/WX20221128-221028@2x.png)\n\n2. 关于获取到视频流后，`video`视频播放，需要镜面翻转，这个可以通过 css 的`transform: rotateY(180deg)`来翻转\n\n3. 关于`video`播放不能在手机上竖屏全屏，可以给 video 设置 css`object-fit:cover`来充满屏幕\n\n```html\n<video id=\"video\" class=\"video\" playsinline autoplay muted></video>\n```\n\n```css\n.video {\n  width: 100%;\n  height: 100%;\n  transform: rotateY(180deg);\n  object-fit: cover;\n}\n```\n\n- 获取摄像头视频流\n\n```javascript\nasync getUserMedia() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    try {\n      // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#examples\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: false,\n        video: true,\n        video: {\n          facingMode: \"user\", // 前置摄像头\n          // facingMode: { exact: \"environment\" }，// 后置摄像头\n          width: { min: 1280, max: 1920 },\n          height: { min: 720, max: 1080 },\n        },\n      });\n\n      return Promise.resolve(stream);\n    } catch (error) {\n      return Promise.reject();\n    }\n  }\n\n  const errorMessage =\n    \"This browser does not support video capture, or this device does not have a camera\";\n  alert(errorMessage);\n}\n```\n\n- video 播放视频流\n\n```javascript\nasync openCamera(e) {\n  try {\n    const stream = await this.getUserMedia();\n    this.video.srcObject = stream;\n    this.video.onloadedmetadata = async () => {\n      this.video.play();\n    };\n  } catch (error) {\n    console.log(error);\n    alert(\"打开摄像头失败\");\n  }\n}\n```\n\n- 关闭视频\n\n```javascript\nasync closeCamera() {\n  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/stop\n  const tracks = this.video.srcObject.getTracks();\n\n  tracks.forEach((track) => {\n    track.stop();\n  });\n\n  this.video.srcObject.srcObject = null;\n}\n```\n\n#### 2.3 检测人脸左右倾斜\n\n![](../img/face-api/landmarks.png)\n\n通过`face-api.js`拿到人脸`landmarks`特征数据后，可以直接拿到左右眼的数据，分别通过求 Y 轴方向的平均值，然后比较这个平均值，便可以简单得出人脸向左还是向右倾斜，简单吧，角度都不用求了！\n\n```html\n<div style=\"position: relative;width: 100%;height: 100%;\">\n  <video\n    id=\"video\"\n    class=\"video\"\n    playsinline\n    autoplay\n    muted\n    style=\"object-fit:cover\"\n  ></video>\n  <canvas id=\"overlay\" class=\"overlay\"></canvas>\n</div>\n```\n\n```css\n.video {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 0;\n  transform: rotateY(180deg);\n}\n\n.overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n```\n\n- 加载模型\n\n```javascript\nimport * as faceapi from \"face-api.js\";\n\nasync loadWeight() {\n  // 加载模型\n  await faceapi.nets.ssdMobilenetv1.load(\n    \"./static/weights/ssd_mobilenetv1_model-weights_manifest.json\"\n  );\n  // 加载人脸68特征模型数据\n  await faceapi.nets.faceLandmark68Net.load(\n    \"./static/weights/face_landmark_68_model-weights_manifest.json\"\n  );\n  // await faceapi.nets.faceExpressionNet.load(\n  //   \"/static/weights/face_expression_model-weights_manifest.json\"\n  // );\n  // await faceapi.nets.faceRecognitionNet.load(\n  //   \"./static/weights/face_recognition_model-weights_manifest.json\"\n  // );\n  await faceapi.nets.ageGenderNet.load(\n    \"./static/weights/age_gender_model-weights_manifest.json\"\n  );\n\n  console.log(\"模型加载完成\");\n}\n```\n\n- 计算人脸左右倾斜\n\n```javascript\nhandleFaceLeftOrRight(landmarks) {\n  const DIFF_NUM = 15; // 偏差\n  let leftEye = landmarks.getLeftEye(); // 左眼数据\n  let rightEye = landmarks.getRightEye(); // 右眼数据\n  // let nose = landmarks.getNose();\n\n  let leftEyeSumPoint = leftEye.reduce((prev, cur) => ({\n    x: prev.x + cur.x,\n    y: prev.y + cur.y,\n  }));\n\n  let rightEyeSumPoint = rightEye.reduce((prev, cur) => ({\n    x: prev.x + cur.x,\n    y: prev.y + cur.y,\n  }));\n\n  // let noseSumPoint = nose.reduce((prev, cur) => ({\n  //   x: prev.x + cur.x,\n  //   y: prev.y + cur.y,\n  // }));\n\n  let leftEyeAvgPoint = {\n    x: leftEyeSumPoint.x / leftEye.length,\n    y: leftEyeSumPoint.y / leftEye.length,\n  };\n\n  let rightEyeAvgPoint = {\n    x: rightEyeSumPoint.x / leftEye.length,\n    y: rightEyeSumPoint.y / leftEye.length,\n  };\n\n  // let noseAvgPoint = {\n  //   x: noseSumPoint.x / leftEye.length,\n  //   y: noseSumPoint.y / leftEye.length,\n  // };\n\n  // console.log(leftEyeAvgPoint, rightEyeAvgPoint, noseAvgPoint);\n  let diff = Math.abs(leftEyeAvgPoint.y - rightEyeAvgPoint.y);\n\n  return diff > DIFF_NUM\n    ? leftEyeAvgPoint.y > rightEyeAvgPoint.y\n      ? \"left\"\n      : \"right\"\n    : \"center\";\n}\n```\n\n- 分析 video 视频流\n\n```javascript\nasync handleVideoFaceTracking(cb) {\n    if (this.closed) {\n      window.cancelAnimationFrame(this.raf);\n      return;\n    }\n\n    const options = new faceapi.SsdMobilenetv1Options();\n\n    let task = faceapi.detectAllFaces(this.video, options);\n    task = task.withFaceLandmarks().withAgeAndGender();\n    const results = await task;\n\n    // overlay为canvas元素\n    // video即为video元素\n    const dims = faceapi.matchDimensions(this.overlay, this.video, true);\n    const resizedResults = faceapi.resizeResults(results, dims);\n\n    // console.log(\"options==>\", options);\n    // console.log(\"resizedResults==>\", resizedResults);\n    cb && cb(resizedResults);\n\n    this.raf = requestAnimationFrame(() => this.handleVideoFaceTracking(cb));\n  }\n```\n\n### 3. 参考资料\n\n1. [face-api.js](https://github.com/justadudewhohacks/face-api.js)\n\n2. [getUserMedia MDN](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#examples)\n"},{"id":"n55_1Ve1eYvIlm9Hq6VRq","title":"uniapp 打包 h5 问题总结","keywords":["uniapp"," webpack4.x"],"date":"2022-08-08 22:15:07","fileName":"uniapp","content":"\n[本文掘金链接](https://juejin.cn/post/7129492032241795080/)\n\n# uniapp 打包 h5 问题总结\n\n![ ](../img/uniapp/banner.jpeg)\n\n本文对应操作系统及 hbuilderx 版本等\n\n| -         | -               |\n| --------- | --------------- |\n| 操作系统  | macOS           |\n| HbuilderX | 3.4.18.20220630 |\n| Vue       | 2.x             |\n| uView     | 1.x             |\n\n---\n\n## 1. 项目背景\n\n这是一个嵌套在 flutter 里的 h5 项目，外面壳子是 app，里面大部分的页面是 h5，app 直接用 webview 显示 h5 页面\n\n## 2. 开发 h5 为什么要用 uniapp?\n\n因为还要开发微信小程序，使用 uniapp，可以跨平台，节省时间\n\n## 3. 项目初始化\n\n项目初始化是使用[HBuilderX 可视化界面](https://uniapp.dcloud.net.cn/quickstart-hx.html)创建的项目，没有使用[vue-cli 命令行](https://uniapp.dcloud.net.cn/quickstart-cli.html)的方式。\n\n通过官方 IDE 的方式创建的项目，这给后面项目 CI/CD 构建部署，就带来了麻烦。因为不是命令行创建的项目，没法在 linux 里执行命令，只有在本地打包完，然后上传打包完的`unpackage`目录进行部署。当然使用 HBuilderX 也有很多方便的地方。\n\n### 3.1 uni-app HBuilderX 工程与 vue-cli 工程相互转换\n\n[HBuilderX 工程转换为 vue-cli 工程](https://ask.dcloud.net.cn/article/35750)，看到评论区有坑，而且项目一大，遇到坑不一定能解决掉，这样代价就大了。\n\n### 3.2 通过 HBuilderX 方式创建的项目，可以调用 hbuilderx 的打包命令吗？\n\n也就是通过命令行调用 hbuilderx 的打包功能\n\n- [CLI 发行 uni-app 到 H5](https://hx.dcloud.net.cn/cli/publish-h5)\n- [cli 配置环境变量](https://hx.dcloud.net.cn/cli/env)\n\n但是这样还是没有一开始通过 vue-cli 命令行的方式方便，而且都是在本地 windows 或者 mac 上打包，没法在 linux 上通过 shell 脚本执行打包。最终只能是本地打包完，上传 git 仓库。这里有优雅的解决方式的，评论区分享下。\n\n### 3.3 通过 HBuilderX 方式创建的项目，可以使用 npm 吗？\n\n官方文档明确说，可以的\n\n## 4. 生产打包去除`console`\n\n[官方文档](https://uniapp.dcloud.net.cn/collocation/vue-config.html)\n\n```javascript\n// vue.config.js\n\nmodule.exports = {\n  chainWebpack: (config) => {\n    // 发行或运行时启用了压缩时会生效\n    config.optimization.minimizer(\"terser\").tap((args) => {\n      const compress = args[0].terserOptions.compress;\n      // 非 App 平台移除 console 代码(包含所有 console 方法，如 log,debug,info...)\n      compress.drop_console = true;\n      compress.pure_funcs = [\n        \"__f__\", // App 平台 vue 移除日志代码\n        // 'console.debug' // 可移除指定的 console 方法\n      ];\n      return args;\n    });\n  },\n};\n```\n\n## 5. HBuilderX 创建的项目打包时如何区分环境？\n\n意思就是，如何像执行`npm run build:dev`执行的测试环境打包，`npm run build:prod`执行的是生产环境打包。\n\n[官方文档](https://uniapp.dcloud.net.cn/collocation/package.html#%E6%A6%82%E8%BF%B0)\n\n自定义发行-package.json 中添加配置\n\n```json\n{\n  \"uni-app\": {\n    \"scripts\": {\n      \"h5-prod\": {\n        \"title\": \"h5:prod\",\n        \"browser\": \"\",\n        \"env\": {\n          \"UNI_PLATFORM\": \"h5\",\n          \"NODE_ENV\": \"production\",\n          \"DEPLOY_ENV\": \"prod\"\n        },\n        \"define\": {\n          \"CUSTOM-CONST\": true\n        }\n      },\n      \"h5-dev\": {\n        \"title\": \"h5:dev\",\n        \"browser\": \"\",\n        \"env\": {\n          \"UNI_PLATFORM\": \"h5\",\n          \"NODE_ENV\": \"development\",\n          \"DEPLOY_ENV\": \"dev\"\n        },\n        \"define\": {\n          \"CUSTOM-CONST\": true\n        }\n      }\n    }\n  }\n}\n```\n\n添加后，本地开发，就可以在菜单`运行 - h5:dev`本地启动项目，`发行 - 自定义发行 - h5:dev`测试环境打包，当然点击`发行 - 自定义发行 - h5:prod`是生产环境打包。\n\n## 6. 根目录`vue.config.js`中如何获取到自定义 `process` 变量？\n\n因为想在测试环境打包时保留代码中的 debugger 日志，生产环境打包的时候去除日志打印。\n\n像上面定义的`process.env.DEPLOY_ENV`这个变量，业务代码中可以正常获取到，但是在 vue.config.js 这个配置文件中拿不到。\n\n1. 安装`dotenv`\n\n```bash\nnpm i dotenv -D\n```\n\n2. 修改`vue.config.js`\n\n```javascript\nrequire(\"dotenv\").config();\n\nmodule.exports = {\n  chainWebpack(config) {\n    config.when(process.env.NODE_ENV === \"production\", (config) => {\n      // 我们可以拿到process.env.UNI_SCRIPT这个变量来进行操作\n      if (process.env.UNI_SCRIPT === \"h5-prod\") {\n        // https://uniapp.dcloud.io/collocation/vue-config.html\n        // 发行或运行时启用了压缩时会生效\n        config.optimization.minimizer(\"terser\").tap((args) => {\n          const compress = args[0].terserOptions.compress;\n          compress.drop_console = true;\n          compress.pure_funcs = [\n            \"__f__\", // App 平台 vue 移除日志代码\n          ];\n          return args;\n        });\n      }\n    });\n  },\n};\n```\n\n## 7. 打包 h5 过后文件名过长问题\n\n项目稍微大点，页面目录嵌套深一点，打包出来的文件名称巨长，甚至达到 100 字符长度以上。文件名过长，就会带来很恶心的问题，比如被 nginx 拦截，拿不到文件内容，导致页面挂掉。\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.when(process.env.NODE_ENV === \"production\", (config) => {\n      config.output\n        .filename(\"static/js/[name]-[contenthash].js\")\n        .chunkFilename(\"static/js/[id]-[chunkhash].js\");\n    });\n\n    config.optimization.splitChunks({\n      name: function (module, chunks, cacheGroupKey) {\n        const moduleFileName = module\n          .identifier()\n          .split(\"/\")\n          .reduceRight((item) => item);\n        const allChunksNames = chunks.map((item) => item.name).join(\"~\");\n        return `${moduleFileName}`;\n      },\n    });\n  },\n};\n```\n\n## 8. 打包 h5 后`chunk-vendors`文件体积过大，而且页面部署后打开也很慢\n\n庆幸的是，暴露了`vue.config.js`这个文件交给开发者，不然处理起来真的头大。\n\n### 8.1 首先启用`manifest.json`配置文件中的`tree-shaking`配置，“摇掉”那些冗余代码\n\n### 8.2 移除 prefetch 插件\n\n```javascript\n// 这个视自己的项目而定\n// vue.config.js\nmodule.exports = {\n  chainWebpack: (config) => {\n    // 移除 prefetch 插件\n    // https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch\n    config.plugins.delete(\"prefetch\");\n  },\n};\n```\n\n### 8.3 打包进行 gz 或 br 压缩\n\n1. 安装`compression-webpack-plugin`\n\n> 这里有一个问题，7.x 版本后只支持 webpack5.x 版本，这里是 webpack4.x，只能使用 6.x 版本\n> https://github.com/webpack-contrib/compression-webpack-plugin/releases?page=2\n\n```txt\n7.0.0 (2020-12-02)\n\nBREAKING CHANGES\n  minimum supported webpack version is ^5.1.0\n```\n\n安装\n\n```bash\nnpm i compression-webpack-plugin@6.1.1 -D\n```\n\n2. 修改 vue.config.js\n\n```javascript\n// vue.config.js\nconst CompressionPlugin = require(\"compression-webpack-plugin\");\n\nmodule.exports = {\n  configureWebpack: (config) => {\n    if (process.env.NODE_ENV === \"production\") {\n      config.plugins.push(\n        new CompressionPlugin({\n          filename: \"[path][base].gz\",\n          algorithm: \"gzip\",\n          test: /\\.(js|css|html)$/,\n          threshold: 10240,\n          minRatio: 0.8,\n          deleteOriginalAssets: false,\n        })\n      );\n    }\n  },\n};\n```\n\n3. 同时 nginx 开启 gzip\n\n```nginx\nserver {\n  gzip on; #开启gzip\n  # gzip_buffers 32 4k; #设置压缩所需要的缓冲区大小，以4k为单位，如果文件为32k则申请32*4k的缓冲区\n  gzip_comp_level 6; #gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间\n  gzip_min_length 4000; #gizp压缩起点，文件大于4k才进行压缩\n  gzip_vary on; # 是否在http header中添加Vary: Accept-Encoding，建议开启\n  gzip_static on; #nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩\n  # gzip_types text/xml text/javascript application/javascript text/css text/plain application/json application/x-javascript; # 进行压缩的文件类型\n}\n```\n\n### 8.4 结合`webpack-bundle-analyzer`生成的模块分析图来拆分 chunk-vendors\n\n#### 8.4.1 安装`webpack-bundle-analyzer`\n\n```bash\nnpm i webpack-bundle-analyzer -D\n```\n\n#### 8.4.2 引入`webpack-bundle-analyzer`\n\n```javascript\nconst BundleAnalyzerPlugin =\n  require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n\nmodule.exports = {\n  configureWebpack: (config) => {\n    config.plugins.push(new BundleAnalyzerPlugin());\n  },\n};\n```\n\n如下图所示,chunk-vendors 的组成，是把那些公共的依赖全部都打包在一起了，文件大小达到 1M 以上，严重影响页面加载速度，生成环境上 gzip 压缩后，首页加载也需要将近 10s 左右，令人汗颜。(这里的拆分视具体项目而定)\n\n![ ](../img/uniapp/old-chunk-vendors.png)\n\n- 需要将`@dcloudio`(658kb)拆分为\"uni-h5\"部分和\"vue-cli-plugin-uni\"部分\n- 将`core-js`(282kb)单独拆出来\n- 将`node-rsa`(112kb)单独拆出来\n- 将`bn.js`(88kb)单独拆出来\n- ...\n\n入口 index 文件也达到了几乎 350kb，里面有一个大的 pages.json 文件\n\n![ ](../img/uniapp/old-index.png)\n\n- 将`pages.json`(290kb)单独拆出来\n\n在浏览器上看 chunk-vendors，还有一个`buffer`模块\n\n![ ](../img/uniapp/old-chunk-vendors-js.png)\n\n- 将`buffer`模块单独拆出来\n\n#### 8.4.3 `optimization.splitChunks`拆分模块\n\n> 这里是 webpack4\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.optimization.splitChunks({\n      chunks: \"all\", // 必须三选一： \"initial\"(同步包) | \"all\"(推荐，同步或异步包) | \"async\" (默认就是async，异步包)\n      automaticNameDelimiter: \"~\", // 打包分隔符\n      name: function (module, chunks, cacheGroupKey) {\n        const moduleFileName = module\n          .identifier()\n          .split(\"/\")\n          .reduceRight((item) => item);\n        const allChunksNames = chunks.map((item) => item.name).join(\"~\");\n        return `${moduleFileName}`;\n      },\n      cacheGroups: {\n        vendors: {\n          name: \"chunk-vendors\",\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true, // 遇到重复包直接引用，不重新打包\n          priority: 0, // 打包优先级权重值\n          // minChunks: 1,  // 引用超过一次直接打包到chunk中\n          minSize: 30000,\n        },\n        pages: {\n          name: \"chunk-pages\",\n          test: /pages\\.json$/,\n          chunks: \"all\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 90,\n          minChunks: 1,\n          minSize: 10000,\n        },\n        \"node-rsa\": {\n          name: \"chunk-node-rsa\",\n          test: /node-rsa/,\n          chunks: \"all\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 70,\n        },\n        buffer: {\n          name: \"chunk-buffer\",\n          test: /buffer|is-buffer/,\n          chunks: \"all\",\n          reuseExistingChunk: true,\n          priority: 90,\n          minChunks: 1,\n          minSize: 15000,\n          enforce: true,\n        },\n        \"core-js\": {\n          name: \"chunk-core-js\",\n          test: /core-js/,\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 70,\n        },\n        \"uni-h5\": {\n          name: \"chunk-uni-h5\",\n          test: /uni-h5/,\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 80,\n        },\n        vue: {\n          name: \"chunk-vue\",\n          test: /vue-cli-plugin-uni/,\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 85,\n        },\n        bn: {\n          name: \"chunk-bn\",\n          test: /bn/,\n          chunks: \"initial\",\n          reuseExistingChunk: true,\n          enforce: true,\n          priority: 70,\n        },\n      },\n    });\n\n    // 提取公共的runtime\n    config.optimization.runtimeChunk(\"single\");\n  },\n};\n```\n\n#### 8.4.4 拆分的 chunk 没有在`index.html`中自动引入\n\n> 打包很成功，没任何报错，但是在运行项目的时候，页面一片空白，没任何 ui 展示。**问题就出在，拆分出来的各个小 chunk，没有自动在 index.html 中引入**，我们可以在打包出来的 unpackage 目录，本地启动一个静态服务，把那些 chunk 手动引入，刷新页面，页面 ui 显示出来了\n\n**所以我们需要找到[html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)的配置，把我们单独拆分出来的 chunk，添加到`chunks`配置中**\n\n```javascript\n// vue.config.js\nfunction changeHtmlWebpackPluginChunks(config) {\n  const plugins = config.plugins;\n  const chunkArr = [\n    \"runtime\",\n    \"chunk-vue\",\n    \"chunk-uni-h5\",\n    \"chunk-core-js\",\n    \"chunk-node-rsa\",\n    \"chunk-buffer\",\n    \"chunk-bn\",\n    \"chunk-pages\",\n  ];\n\n  plugins.forEach((item, index) => {\n    // 为HtmlWebpackPlugin\n    if (\n      item.options &&\n      Object.prototype.toString.call(item.options) === \"[object Object]\" &&\n      Object.hasOwnProperty.call(item.options, \"filename\") &&\n      Object.hasOwnProperty.call(item.options, \"chunks\") &&\n      item.options.filename === \"index.html\"\n    ) {\n      const oldChunks = item.options.chunks || [];\n      // 修改chunks引入\n      item.options.chunks = [...chunkArr, ...oldChunks];\n    }\n  });\n}\n\nmodule.exports = {\n  configureWebpack: (config) => {\n    if (process.env.NODE_ENV === \"production\") {\n      changeHtmlWebpackPluginChunks(config);\n    }\n  },\n};\n```\n\n下图是拆分后 chunk-vendors，和之前对比，那些大模块都被拆分出去了，文件体积也从 1M 多变成了 320kb，首页加载也从 10s 多变成了 3s 左右。\n\n![ ](../img/uniapp/new-chunk-vendors.png)\n\n#### 8.4.5 关于拆分 vendors 后，`uview-ui`部分组件报错\n\n> 项目中使用到了`uview-ui`ui 框架\n\n重新打包，本地再次启动项目，浏览器控制台发现如下报错\n\n![ ](../img/uniapp/console.png)\n\n再到 unpackage 目录一看，居然还有`u-icon.vue`和`u-line.vue`未打包！\n\n那单独提取这两个文件为 chunk 进行打包，再次打包后启动项目，这两个组件没报错，其他组件报错了，unpackage 目录里出现了更多的\"u-xx.vue\"组件，这是什么情况？\n\n猜测是引入 uview-ui 框架时的[easycom 组件模式](https://v1.uviewui.com/components/npmSetting.html)惹得鬼，我尝试着在 easycom 里添加自定义`custom`配置，把这两个组件写在里面，但是不管用。页面不报错，但是样式出问题了。。。\n\n或者直接删除 easycom 配置进行，启动项目，页面样式出问题了。。。\n\n最终还是在`splitChunks`里单独提取 uview-ui 为 chunk，这样问题是解决了，但是这样在入口的时候，就要加载一个提取出来的 uview-ui(项目中使用到的所有 uview-ui 组件，并非整个 uview-ui)。未拆分前，每个页面只需加载自己所需的组件，现在把所有页面的组件都提取出来了，等于是每个页面都加载了冗余的 uview-ui 组件。好在是最终页面加载速度是比之前快了。\n\n这里有知道怎么处理的，或者有遇到相同问题的，分享下怎么处理。\n\n#### 8.4.6 拆分为各个小 chunk 后，页面 js 请求变多了\n\n![ ](../img/uniapp/new-console.png)\n\n页面 js 请求变多，对页面性能也有一定影响，所以这里拆分，视具体项目而定。\n\n## 9. hbuilderx 创建的项目,h5 持续部署\n\n> 这里视公司内部情况而定，我这是服务器上有现成的 nginx,也无需自己打包 docker 镜像\n\n1. `.gitlab.yml`\n\n> SSH_USERNAME,SSH_HOST,SSH_PASSWORD 这 3 个变量写在项目`Setting->CI/CD->Variables`里\n\n```yml\nstages:\n  - build\n\njob_build:\n  stage: build\n  script:\n    # - sudo docker image build -t demo_h5 .\n    # - sudo docker tag demo_h5 registry.cn-hangzhou.aliyuncs.com/test-blog/demo_h5:latest\n    # - sudo docker login --username=$ALIYUN_DOCKER_NAME registry.cn-hangzhou.aliyuncs.com --password=$ALIYUN_DOCKER_PASSWORD\n    # - sudo docker push registry.cn-hangzhou.aliyuncs.com/test-blog/demo_h5:latest\n    # - sudo docker logout\n    - if yum list installed | grep 'sshpass'; then echo yes; else yum -y install sshpass;fi\n    - sh deploy.sh $SSH_USERNAME $SSH_HOST $SSH_PASSWORD\n  tags:\n    # 公司内部gitlab注册一个runner,或者写一个公共runner\n    - xxxx\n  only:\n    - main\n```\n\n2. `deploy.sh`\n\n> 将打包出来的文件，上传到服务器指定目录，然后页面就可以访问了\n>\n> 为什么要将打包出来的代码进行压缩，因为打包出来的文件数量很多，如果一个个传输，会非常慢，所以要进行压缩后变成 1 个文件进行传输\n\n```sh\n#!/bin/bash\n\necho \"ssh deploy start==>\"\n# echo \"$3\" ssh \"$1\"@\"$2\" --password-stdin\n\nusername=$1\nhost=$2\npassword=$3\n# 打包目录\ndir=\"./unpackage/dist/build/h5\"\n# 服务器目录\ntarget=\"/home/demo_h5/nginx/html/app-web\"\n\n# 上传本地文件到服务器\n# scp /path/filename username@servername:/path\n# 上传目录到服务器\n# scp -r local_dir username@servername:remote_dir\n\n# sshpass -p ${password} scp ${dir}/index.html ${username}@${host}:/home/demo_h5/nginx/html/app-web\n# sshpass -p ${password} scp -r ${dir}/static ${username}@${host}:/home/demo_h5/nginx/html/app-web\n\n# cd到指定目录\ncd ${dir}\n# 压缩所有文件并重命名\nzip -r -q -o build.zip ./\n# 通过sshpass上传压缩文件到指定目录\nsshpass -p ${password} scp ./build.zip ${username}@${host}:${target}\nsleep 2\n\n# 登录远程服务器\n# cd 到指定目录\n# unzip 解压到指定目录\n#   -o 不必先询问用户，unzip执行后覆盖原有文件。\n#   -d 解压到指定目录\n# 删除压缩文件\n\nsshpass -p ${password} ssh ${username}@${host} \"cd /home/demo_h5/nginx/html/app-web && pwd && unzip -o -q ./build.zip -d ./ && rm -rf ./build.zip\"\n\necho \"ssh deploy end==>\"\n```\n\n3. git 提交代码\n\n不出意外，代码自动部署到相应位置，浏览器可以访问了\n\n```log\n$ if yum list installed | grep 'sshpass'; then echo yes; else yum -y install sshpass;fi\nRepository base is listed more than once in the configuration\nRepository updates is listed more than once in the configuration\nRepository extras is listed more than once in the configuration\nRepository centosplus is listed more than once in the configuration\nRepodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast\nsshpass.x86_64                              1.06-2.el7                 @extras\nyes\n$ sh deploy.sh $SSH_USERNAME $SSH_HOST $SSH_PASSWORD\nssh deploy start==>\n/home/demo_h5/nginx/html/app-web\nssh deploy end==>\nJob succeeded\n```\n\n## 10. 参考资料\n\n1. [uniapp 官方文档](https://uniapp.dcloud.net.cn/)\n2. [webpack4 官方文档](https://v4.webpack.docschina.org/concepts/)\n3. [vue-cli 官方文档](https://cli.vuejs.org/zh/guide/)\n"},{"id":"HhcL4KPgeGCOqvUazMOBI","title":"Taro与微信小程序原生组件之间的事件通信","keywords":["taro"," wemark"],"date":"2022-04-04 18:02:42","fileName":"taro-wemark","content":"\n- [小程序博客 github 仓库](https://github.com/sRect/wechat-blog)\n\n- [本小程序链接](#小程序://sRect的个人博客/sRect的个人博客/Z1MPSUtT7bnfPFd)\n\n## 1. 需求背景\n\n最近在做一个微信小程序版的简易博客，原本是准备自己解析`markdown`并渲染，最后还是使用了[`wemark`](https://github.com/TooBug/wemark)第三方组件来渲染，因为自己解析渲染的很难看。\n\n因为小程序内打开第三方链接，需要在项目配置里设置域名才能打开，对于第三方网站链接很无奈，所以干脆直接进行复制，然后可以自行通过浏览器打开。\n\n```javascript\nconst Detail = () => {\n  const mdStr = `...`;\n\n  return (\n    <View id=\"md\" className=\"markdown-body\">\n      <wemark id=\"wemark\" md={mdStr} link highlight type=\"wemark\" />\n    </View>\n  );\n};\n```\n\n![ ](../img/taro-wemark/link.png)\n\n如上图显示，就是想在点击的时候，拿到链接里的 url。\n\n其实熟悉微信小程序的开发，这是一个很简单的需求，但我等彩笔不熟悉。😄\n\n原本还想拿到 dom，然后自己绑定事件，最后发现这样错的离谱。\n\n## 2. 彩笔的错误之路\n\n> **注意**： 以下几种方式都没成功\n\n### 2.1 使用`createSelectorQuery`api\n\n> 打印出来，都没有想要的结果，没法继续下去\n\n```javascript\nimport Taro, { useReady } from \"@tarojs/taro\";\n\nconst Detail = () => {\n  useReady(() => {\n    Taro.createSelectorQuery()\n      .select(\"#md\")\n      .node((res) => {\n        console.log(\"==>\");\n        console.log(res);\n      })\n      .exec();\n  });\n};\n```\n\n或者\n\n```javascript\nuseReady(() => {\n  const query = Taro.createSelectorQuery().in(this);\n\n  query\n    .select(\"#md\")\n    .node(function (res) {\n      console.log(res.node);\n    })\n    .exec();\n});\n```\n\n### 2.2 使用`getCurrentInstance`api\n\n> 打印出来，也没有想要的，无法继续下去\n\n```javascript\nimport { getCurrentInstance } from \"@tarojs/taro\";\n\nconst { page } = getCurrentInstance();\nconst md = page.selectComponent(\"#md\");\n\nconsole.log(md);\n```\n\n### 2.3 直接在最外面绑定事件\n\n> 打印出来，无法区分是否点击在链接上，也无法继续下去\n\n```javascript\nconst Detail = () => {\n  const mdStr = `...`;\n\n  useEffect(() => {\n    const el = document.getElementById(\"md\");\n    function handleClick(event) {\n      console.log(event);\n    }\n    el.addEventListener(\"tap\", handleClick);\n\n    return () => {\n      el.removeEventListener(\"tap\", handleClick);\n    };\n  }, []);\n\n  return (\n    <View id=\"md\" className=\"markdown-body\">\n      <wemark id=\"wemark\" md={mdStr} link highlight type=\"wemark\" />\n    </View>\n  );\n};\n```\n\n## 3. 解决\n\n> 还是得到`wemark`组件里去修改\n\n- `wemark/wemark.js`添加如下代码\n\n```javascript\nComponent({\n  methods: {\n    onTap: function (e) {\n      console.log(\"onTap==>\", e);\n      this.triggerEvent(\"myevent\", e);\n    },\n  },\n});\n```\n\n- `wemark/wemark.wxml`中添加`data-url`和添加事件绑定\n\n```html\n<navigator\n  class=\"wemark_inline_link\"\n  url=\"{{renderInline.data.href}}\"\n  wx:if=\"{{renderInline.type === 'link'}}\"\n  data-url=\"{{renderInline.data.href}}\"\n  bindtap=\"onTap\"\n>\n  {{renderInline.content}}\n</navigator>\n```\n\n- 回到自己代码中修改\n\n```javascript\nconst Detail = () => {\n  const mdStr = `...`;\n\n  // 链接复制\n  const onMyEvent = (e) => {\n    console.log(e);\n\n    const str = e?.detail?.currentTarget?.dataset?.url;\n\n    if (!str) return;\n\n    Taro.setClipboardData({\n      data: str,\n      success() {\n        Taro.showToast({\n          title: \"链接复制成功\",\n          icon: \"success\",\n        });\n      },\n    });\n  };\n\n  return (\n    <View id=\"md\" className=\"markdown-body\">\n      <wemark\n        id=\"wemark\"\n        md={mdStr}\n        link\n        highlight\n        type=\"wemark\"\n        onMyevent={onMyevent}\n      />\n    </View>\n  );\n};\n```\n\n![ ](../img/taro-wemark/dataset.png)\n\n- 至此，解决了这个小需求\n\n## 4. 参考链接\n\n1. [组件间通信与事件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html)\n\n2. [原生项目使用 Taro](https://taro-docs.jd.com/taro/docs/taro-in-miniapp/#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6)\n"},{"id":"dHg5T1zS3Ur0q-4FueL9k","title":"mermaid使用","keywords":["mermaid"],"date":"2022-3-11 16:28:48","fileName":"mermaid","content":"\nmermaid 流程图 + 饼图使用\n\n# img\n\n![img](../img/mermaid/test5.png)\n\n## table\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :----- | -----: | :------: |\n| 单元格 | 单元格 |  单元格  |\n| 单元格 | 单元格 |  单元格  |\n\n## 流程图\n\n```mermaid\nflowchart TB\nA[Hard] -->|Text| B(Round)\nB --> C{Decision}\nC -->|One| D[Result 1]\nC -->|Two| E(Result 2)\n```\n\n## 饼图\n\n> https://mermaid-js.github.io/mermaid/#/pie\n\n```mermaid\npie\ntitle Pets adopted by volunteers\n\"Dogs\" : 386\n\"Cats\" : 85\n\"Rats\" : 15\n```\n\n## 参考\n\n1. [mermaid](https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md)\n"},{"id":"w9sIDIftjljEsu0qEmz9-","title":"微信小程序持续获取定位测试","keywords":["微信小程序"," Tarojs"],"date":"2021-11-03","fileName":"location","content":"\n- [github 源码仓库](https://github.com/sRect/taro_wx)\n\n### 1. 客户端详情\n\n> 文章内使用 Tarojs 开发微信小程序\n\n- 手机型号：小米 10\n- 操作系统及版本：Android 10\n- 客户端平台：android\n- SDKVersion：2.20.2\n\n### 2. 注意点\n\n1. taro 项目配置文件`src/app.config.js`中要添加以下配置\n\n```javascript\nexport default {\n  requiredBackgroundModes: [\"location\"],\n  permission: {\n    \"scope.userLocation\": {\n      desc: \"如实填写实际用途\", // 高速公路行驶持续后台定位\n    },\n  },\n};\n```\n\n2. 检查手机是否打开位置信息开关\n\n```javascript\nTaro.getSystemInfoAsync({\n  success(data) {\n    console.log(data.locationEnabled);\n  },\n});\n```\n\n3. 检查是否给微信开了定位权限\n\n```javascript\nTaro.getSystemInfoAsync({\n  success(data) {\n    console.log(data.locationAuthorized);\n  },\n});\n```\n\n4. 检查当前小程序是否开了后台定位权限\n\n```javascript\nTaro.getSetting({\n  success(res) {\n    const authSetting = res.authSetting;\n    if (\n      !authSetting[\"scope.userLocation\"] ||\n      !authSetting[\"scope.userLocationBackground\"]\n    ) {\n      // 让用户在弹出的选项中务必勾选“使用小程序期间和离开小程序之后”选项\n      Taro.openSetting();\n    }\n  },\n});\n```\n\n### 3. 完整代码\n\n```jsx\nimport React, { useState } from \"react\";\nimport Taro, { useReady, useDidShow, useDidHide } from \"@tarojs/taro\";\nimport { View, Map } from \"@tarojs/components\";\n\nconst hasOwnProperty = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nconst HandleLocation = () => {\n  const [systemSetting, setSystemSetting] = useState({});\n  const [location, setLocation] = useState({ longitude: \"\", latitude: \"\" });\n  const [locationList, setLocationList] = useState([]);\n\n  const handleGetLocation = () => {\n    if (Taro.canIUse(\"startLocationUpdateBackground\")) {\n      // https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html\n      // 小程序全局配置\n      // https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#permission\n      // wx.authorize({scope: \"scope.userInfo\"})，不会弹出授权窗口，请使用 <button open-type=\"getUserInfo\"/>\n      // 需要授权 scope.userLocation、scope.userLocationBackground 时必须配置地理位置用途说明\n\n      Taro.startLocationUpdateBackground({\n        success() {\n          Taro.onLocationChange((data) => {\n            setLocationList((pre) => [...pre, data]);\n\n            setLocation({ longitude: data.longitude, latitude: data.latitude });\n\n            // ajax发送数据到后台\n            // ...\n          });\n        },\n        fail(err) {\n          console.log(err);\n          Taro.showToast({\n            icon: \"error\",\n            title: \"定位失败\",\n          });\n\n          Taro.openSetting();\n        },\n      });\n    } else {\n      Taro.showToast({\n        icon: \"error\",\n        title: \"您的设备暂不支持定位\",\n      });\n    }\n  };\n\n  // 检查手机是否打开位置信息开关\n  // 检查是否给微信开了定位权限\n  const checkMobileLocationAuth = () => {\n    return new Promise((resolve, reject) => {\n      Taro.getSystemInfoAsync({\n        success(data) {\n          setSystemSetting(data);\n\n          if (\n            data &&\n            hasOwnProperty(data, \"locationEnabled\") &&\n            !data.locationEnabled\n          ) {\n            Taro.showModal({\n              title: \"提示\",\n              content: \"请打开手机设置-位置信息(GPS)开关\",\n              confirmText: \"确定\",\n              showCancel: false,\n            });\n\n            reject();\n          }\n\n          if (\n            data &&\n            hasOwnProperty(data, \"locationAuthorized\") &&\n            !data.locationAuthorized\n          ) {\n            Taro.showModal({\n              title: \"提示\",\n              content:\n                \"请打开手机设置-应用设置-应用管理-微信-权限管理-定位权限开关\",\n              confirmText: \"确定\",\n              showCancel: false,\n              success() {\n                // Taro.openSetting();\n              },\n            });\n\n            reject();\n          }\n\n          resolve();\n        },\n        fail() {\n          reject();\n        },\n      });\n    });\n  };\n\n  // 检查当前小程序是否开了定位权限\n  const checkMiniAppLocationAuth = () => {\n    return new Promise((resolve, reject) => {\n      if (!Taro.canIUse(\"getSetting\")) return reject();\n\n      Taro.getSetting({\n        success: function (res) {\n          const authSetting = res.authSetting;\n\n          if (\n            authSetting &&\n            hasOwnProperty(authSetting, \"scope.userLocation\") &&\n            hasOwnProperty(authSetting, \"scope.userLocationBackground\") &&\n            authSetting[\"scope.userLocation\"] &&\n            authSetting[\"scope.userLocationBackground\"]\n          ) {\n            resolve();\n          } else {\n            if (Taro.canIUse(\"openSetting\")) {\n              Taro.showModal({\n                title: \"提示\",\n                content:\n                  \"请在点击确定后，在弹出的选项中务必勾选“使用小程序期间和离开小程序之后”选项\",\n                confirmText: \"确定\",\n                showCancel: false,\n                success() {\n                  Taro.openSetting();\n                },\n              });\n            } else {\n              Taro.showModal({\n                title: \"提示\",\n                content:\n                  \"请点击右上角“...”更多-设置-位置信息，在弹出的选项中务必勾选“使用小程序期间和离开小程序之后”选项\",\n                confirmText: \"确定\",\n                showCancel: false,\n              });\n            }\n\n            reject();\n          }\n        },\n      });\n    });\n  };\n\n  useReady(() => {\n    console.log(\"useReady==>\");\n  });\n\n  useDidShow(() => {\n    console.log(\"useDidShow==>\");\n    if (Taro.canIUse(\"stopLocationUpdate\")) {\n      Taro.stopLocationUpdate({\n        complete() {\n          checkMobileLocationAuth()\n            .then(checkMiniAppLocationAuth)\n            .then(() => {\n              // 全部ok，可以进行持续定位\n              handleGetLocation();\n            })\n            .catch(() => {\n              console.log(\"err==>\");\n            });\n        },\n      });\n    }\n  });\n\n  useDidHide(() => {\n    console.log(\"useDidHide==>\");\n  });\n\n  return (\n    <View>\n      <Map\n        style=\"width: 100%; height: 200px;\"\n        scale={16}\n        longitude={location.longitude}\n        latitude={location.latitude}\n      />\n    </View>\n  );\n};\n```\n\n### 4. 总结\n\n- 经过本地开发实际测试，把小程序切到后台后，切换到其他 app\n- 或者手机直接锁屏\n\n以上两种情况，1 分钟后，`startLocationUpdateBackground`api 即失效，只有重新解锁手机，重新回到微信，api 的实时位置监控才被唤醒，尚未找到解决方法\n\n### 5. 其他\n\n钉钉小程序`dd.getLocation`只有当前钉钉小程序当前在激活状态下可以获取到，切换到后台和手机锁屏后，即失效\n\n### 6. 参考资料\n\n1. [微信小程序授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)\n2. [微信小程序全局配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#permission)\n"},{"id":"_ZDuShySVisiKi1uR6yOV","title":"微前端qiankun上手体验","keywords":["微前端"," single-spa"," qiankun"],"date":"2021-02-25","fileName":"qiankun","content":"\n> 1. [qiankun 官方文档](https://qiankun.umijs.org/zh)\n> 2. [single-spa](https://zh-hans.single-spa.js.org/docs/getting-started-overview/)\n> 3. [微前端-最容易看懂的微前端知识](https://juejin.cn/post/6844904162509979662#heading-0)\n\n微前端的类型：\n\n1. 受路由控制渲染的子应用\n2. 不受路由控制的组件\n3. 非渲染组件，应用间通信逻辑\n\n### 1.子应用-vue\n\n#### 1. vue-cli 创建子应用\n\n```shell\nvue create qiankun_vue\n```\n\n#### 2. 修改入口`main.js`文件\n\n```javascript\n// https://qiankun.umijs.org/zh/guide/tutorial#vue-微应用\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\nimport router from \"./router\";\n\n// Vue.config.productionTip = false\n\nlet vueInstance = null;\nfunction render(props = {}) {\n  const { container } = props;\n\n  vueInstance = new Vue({\n    router,\n    render: (h) => h(App),\n    // 这里是挂载到自己的html上，基座会拿到这个挂载后的html，将其插入到相应的容器里\n\n    // Application died in status NOT_MOUNTED: Target container with #container not existed after xxx mounted!\n    // 微应用的根 id 与其他 DOM 冲突。解决办法是：修改根 id 的查找范围。\n  }).$mount(container ? container.querySelector(\"#app\") : \"#app\");\n}\n\n// 使用 webpack 运行时 publicPath 配置\n// 动态设置publicPath\nif (window.__POWERED_BY_QIANKUN__) {\n  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n}\n\n// https://qiankun.umijs.org/zh/faq#如何独立运行微应用？\nif (!window.__POWERED_BY_QIANKUN__) {\n  render();\n}\n\n// 暴露3个异步方法 bootstrap mount unmount\nexport async function bootstrap(props) {}\nexport async function mount(props) {\n  console.log(\"props=====>\", props);\n  render(props);\n}\nexport async function unmount(props) {\n  vueInstance && vueInstance.$destroy();\n}\n```\n\n#### 3. 修改路由`router/index.js`文件\n\n```diff\n  const router = new VueRouter({\n    mode: 'history',\n-    base: process.env.BASE_URL,\n+    base: window.__POWERED_BY_QIANKUN__ ? '/vue' : process.env.BASE_URL,\n    routes\n  })\n\n```\n\n#### 4. 根目录新建`vue.config.js`，修改打包配置\n\n```javascript\nmodule.exports = {\n  devServer: {\n    port: 8000,\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n    },\n  },\n  // https://webpack.docschina.org/configuration/output/#outputlibrary\n  configureWebpack: {\n    output: {\n      library: \"vueApp\", // 打包成一个类库\n      libraryTarget: \"umd\", // umd最终会把bootstrap/mount/unmount挂载到window上\n    },\n  },\n};\n```\n\n### 2.子应用-react\n\n#### 1. create-react-app 创建子应用\n\n```\ncreate-react-app qiankun_react\n```\n\n#### 2. 修改入口`index.js`文件\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter, Link, Route } from \"react-router-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n// import reportWebVitals from './reportWebVitals';\n\nfunction render(props) {\n  const { container } = props;\n  // https://reactrouter.com/web/api/BrowserRouter\n  ReactDOM.render(\n    <React.StrictMode>\n      <BrowserRouter basename=\"/react\">\n        <Link to=\"/\">react-home</Link> |<Link to=\"/about\">react-about</Link>\n        {/* exact 严格模式 */}\n        <Route path=\"/\" exact render={() => <App />}></Route>\n        <Route\n          path=\"/about\"\n          exact\n          render={() => <div>react about page</div>}\n        ></Route>\n      </BrowserRouter>\n    </React.StrictMode>,\n    container\n      ? container.querySelector(\"#root\")\n      : document.querySelector(\"#root\")\n  );\n}\n\n// 独立运行\nif (!window.__POWERED_BY_QIANKUN__) {\n  render();\n}\n\nexport async function bootstrap(props) {}\nexport async function mount(props) {\n  render(props);\n}\nexport async function unmount(props) {\n  const { container } = props;\n  ReactDOM.unmountComponentAtNode(\n    container\n      ? container.querySelector(\"#root\")\n      : document.querySelector(\"#root\")\n  );\n}\n```\n\n#### 3. 修改打包配置文件\n\n##### 1. 安装`react-app-rewired`\n\n```shell\nyarn add react-app-rewired -D\n```\n\n##### 2. 子应用根目录新建`config-overrides.js`文件\n\n```javascript\n// https://github.com/timarney/react-app-rewired/blob/HEAD/README_zh.md#扩展配置选项\nmodule.exports = {\n  webpack: (config) => {\n    config.output.library = \"reactApp\";\n    config.output.libraryTarget = \"umd\";\n    config.output.publicPath = \"http://localhost:9000/\";\n    return config;\n  },\n  devServer: (configFunc) => {\n    return (proxy, allowedHost) => {\n      const config = configFunc(proxy, allowedHost);\n      // 设置开发服务允许跨域\n      config.headers = {\n        \"Access-Control-Allow-Origin\": \"*\",\n      };\n\n      return config;\n    };\n  },\n};\n```\n\n##### 3. 设置环境变量\n\n1. 子应用根目录新建`.env`文件\n\n```\nPORT=4000\nWDS_SOCKET_PORT=4000\n```\n\n或者在`package.json`启动脚本中修改端口\n\n```diff\n \"scripts\": {\n-     \"start\": \"react-app-rewired start\",\n+     \"start\": \"set PORT=4000 && react-app-rewired start\",\n   },\n```\n\n2. 修改`package.json`文件\n\n```diff\n \"scripts\": {\n-     \"start\": \"react-scripts start\",\n-     \"build\": \"react-scripts build\",\n-     \"test\": \"react-scripts test\",\n-     \"eject\": \"react-scripts eject\"\n+     \"start\": \"react-app-rewired start\",\n+     \"build\": \"react-app-rewired build\",\n+     \"test\": \"react-app-rewired test\",\n+     \"eject\": \"react-app-rewired eject\"\n   },\n```\n\n### 3.子应用(非 webpack 构建)-jquery+bootstrap\n\n#### 1. 新建`index.html`文件\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>Bootstrap 101 Template</title>\n    <link href=\"//localhost:5000/lib/bootstrap.min.css\" rel=\"stylesheet\" />\n  </head>\n  <body>\n    <div class=\"container\" id=\"app\">\n      <h1>你好，世界！</h1>\n      <div class=\"row\">\n        <div class=\"input-group\">\n          <span class=\"input-group-addon\" id=\"basic-addon1\">@</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"Username\"\n            aria-describedby=\"basic-addon1\"\n          />\n        </div>\n      </div>\n    </div>\n    <script src=\"//localhost:5000/lib/jquery.min.js\"></script>\n    <script src=\"//localhost:5000/lib/bootstrap.min.js\"></script>\n    <!--  entry js为入口文件 -->\n    <script src=\"//localhost:5000/entry.js\"></script>\n  </body>\n</html>\n```\n\n#### 2. 新建`entry.js`入口文件\n\n```javascript\nconst render = ($) => {\n  $(\"#purehtml-container\").html(\"Hello, render with jQuery\");\n  return Promise.resolve();\n};\n((global) => {\n  global[\"purehtml\"] = {\n    bootstrap: () => {\n      console.log(\"purehtml bootstrap\");\n      return Promise.resolve();\n    },\n    mount: () => {\n      console.log(\"purehtml mount\");\n      return render($);\n    },\n    unmount: () => {\n      console.log(\"purehtml unmount\");\n      return Promise.resolve();\n    },\n  };\n})(window);\n```\n\n### 4.基座应用-vue\n\n#### 1.修改入口`main.js`文件\n\n```diff\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\n+ import { registerMicroApps, start } from 'qiankun';\n+ import ElementUI from 'element-ui';\n+ import 'element-ui/lib/theme-chalk/index.css';\n\nVue.config.productionTip = false\n\n+ Vue.use(ElementUI);\n\n+ const apps = [\n+   {\n+     name: \"vueApp\",\n+     // 默认通过fetch加载这个html，解析里面的js，动态的执行\n+     // 注意：子应用必须支持跨域\n+     entry: \"http://localhost:8000\",\n+     container: \"#vueDOM\", // 容器名\n+     activeRule: \"/vue\", // 激活路径\n+     props: { a: 1, b: 2 }, // 传给子应用的参数\n+   },\n+   {\n+     name: \"reactApp\",\n+     entry: \"//localhost:9000\",\n+     container: \"#react\",\n+     activeRule: \"/react\",\n+   },\n+   {\n+     name: \"jqueryApp\",\n+     entry: \"//localhost:5000\",\n+     container: \"#jquery\",\n+     activeRule: \"/jquery\",\n+     props: { a: 100, b: 200 },\n+   },\n+ ];\n+\n+ registerMicroApps(apps); // 注册应用\n+ // 启动应用\n+ start({\n+   // https://qiankun.umijs.org/zh/api#startopts\n+   prefetch: false, // 取消预加载\n+ });\n\nnew Vue({\n  router,\n  render: h => h(App)\n}).$mount('#app')\n```\n\n#### 2. 修改`App.vue`组件\n\n```html\n<template>\n  <div id=\"app\">\n    <el-menu :router=\"true\" mode=\"horizontal\">\n      <!-- 基座自己的路由 -->\n      <el-menu-item index=\"/\">base-home</el-menu-item>\n      <el-menu-item index=\"/about\">base-about</el-menu-item>\n      <!-- 引用其他子应用 -->\n      <el-menu-item index=\"/vue\">vue 应用</el-menu-item>\n      <el-menu-item index=\"/react\">react 应用</el-menu-item>\n      <el-menu-item index=\"/jquery\">jquery + bootstrap 应用</el-menu-item>\n    </el-menu>\n\n    <router-view />\n\n    <div id=\"vueDOM\"></div>\n    <div id=\"react\"></div>\n    <div id=\"jquery\"></div>\n  </div>\n</template>\n```\n"}]}